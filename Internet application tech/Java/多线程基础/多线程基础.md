### 相关概念


#### 程序
程序是为了完成特定任务、用某种语言编写的一组指令的合集，简单地说就是我们写的代码。


#### 进程
进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程：有它自身的产生、存在和消亡的过程。是系统进行资源分配和调度的一个独立单位。

特征：
- 动态性：是程序的一次执行；
- 并发性：进程是可以并发执行；
- 独立性：是系统进行资源分配和调度的一个独立单位；
- 异步性：进程间的相互制约，使进程执行具有间隙；
- 结构性：进程是具有结构的。


#### 线程
线程是由进程创建的，是进程的一个实体。一个进程可以拥有多个线程。


#### 其他
1. 单线程：同一时刻，只允许执行一个线程。
2. 多线程：同一时刻，可以执行多个线程。
3. 并发：同一时刻，多个任务交替执行，造成一种“貌似同时执行”的错觉，简单的说，单核CPU实现的多任务就是并发。
4. 并行：同一个时刻，多个任务同时执行。多核CPU可以实现并行。并发和并行可以同时发生。



### 线程创建


#### 两种方式
Java中线程创建线程有两种方法：
- 继承Thread类，重写run方法；
- 实现Runnable接口，重写run方法，通过new Thread(runnable).start()启动；

![](assets/Pasted%20image%2020220716205731.png)


#### Thread vs Runnable
1. 从Java的设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别。从jdk帮助文档我们可以看到Thread类本身就实现了Runnable接口。
2. 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制，建议使用Runnable。



### 线程终止
1. 当线程完成任务后，会自动退出；
2. 可以通过使用 **变量** 来控制run方法退出的方式停止线程，即 “**通知方式**” 



### 线程常用方法
#### setName
设置线程名称，使之与参数name相同

#### getName
返回该线程的名称

#### start
使该线程开始执行；Java虚拟机底层调用该线程的 start0 本地方法。start底层会创建新的线程，调用 run ，run 就是一个简单的方法调用，不会启动新线程

#### run
调用线程对象 run 方法

#### setPriority
更改线程的优先级，1-10，默认5

#### getPriority  
获取线程的优先级

#### sleep 
在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），静态方法

#### interrupt
中断此线程，但并没有真正的结束线程。所以一般用于中断正在休眠线程。

#### yield
线程的礼让。让出CPU，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功与否。

#### join
线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务。



### 用户线程 vs 守护线程
#### 用户线程
用户线程也叫工作线程，当线程的任务执行完或通知方式结束。

#### 守护线程
一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。常见的守护线程：垃圾回收机制



### 线程的生命周期
![](assets/Pasted%20image%2020220716215029.png)


#### 6 / 7状态
##### New（新建状态）
通过实现Runnable接口或者继承Thread声明一个线程类，new一个实例之后，线程进入新建状态。

##### Runnable
###### Ready（就绪状态)
线程对象创建成功后，调用该线程的start()函数，线程进入就绪状态，该状态的线程进入可运行线程池中，等待获取CPU的使用权。

###### Running（可运行状态）
此时线程调度程序正在从可运行线程池中选择一个线程，该线程进入运行状态。（即线程获取到了cpu时间片）。当线程时间片用完或调用的`yield()`函数，该线程回到就绪状态。

##### Terminated（终止状态）
线程继续运行，直到执行 **结束** 或执行过程中因 **异常意外终止** 都会使线程进入终止状态。线程终止后就 **不能复生** 了。

##### Waiting（等待状态）
运行状态的线程执行`wait()`与`join()`函数会让JVM把该线程放入锁等待队列。处于这种状态的线程不会被分配cpu执行时间，它们要 **等待被主动唤醒** ，否则会一直处于等待状态。

唤醒线程可以通过执行`LockSupport.unpark(t)`函数唤醒指定线程，该线程回到就绪状态。

而通过`notify()`、`notifyAll()`、`join()`线程执行完毕方式，会唤醒锁等待队列的线程，出现的线程回到就绪状态。

##### TimedWaiting（超时等待状态）
超时等待状态（Timed waiting）超时等待与等待状态一样，唯一的区别就是多了超时机制，不会一直等待被其他线程主动唤醒，而是到达指定时间后会自动唤醒。

wait(long)、join(long)、LockSuport.parkNanos(long)、LockSuport.parkUtil(long)、sleep(long)等函数会触发超时等待状态。

wait(long)、join(long)函数会让JVM把线程放入锁等待队列。

超时时间到了，则会进行自动唤醒，后续过程则和等待状态相同。

##### Blocked（阻塞状态）
运行状态的线程 **获取同步锁失败** 或 **发出I/O请求** ，该线程进入阻塞状态。

如果是获取同步锁失败JVM还会把该线程放入锁的同步队列。

同步锁被释放时，锁的同步队列会出队所有线程，进入就绪状态。I/O处理完毕时，该线程重新回到就绪状态。


#### 状态转换图
![](assets/Pasted%20image%2020220716215352.png)

![](assets/Pasted%20image%2020220716225530.png)




### 线程的同步


#### 线程的同步机制
在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性。

也可以这里理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。

![](assets/Pasted%20image%2020220716230307.png)


#### Synchronized
关键字`synchronized`取得的锁都是对象锁，而不是把一段代码或方法（函数）当作锁。这里如果是把一段代码或方法（函数）当作锁，其实获取的也是对象锁，只是监视器（对象）不同而已，哪个线程先执行带synchronized关键字的方法，哪个线程就**持有该方法所属对象的锁**，其他线程都只能呈等待状态。但是这有个前提：既然锁叫做对象锁，那么势必和对象相关，所以**多个线程访问的必须是同一个对象**。


简单地说：
- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁。
- `synchronized` 关键字加到实例方法上是给对象实例上锁。
- 见“互斥锁”![互斥锁](#互斥锁)


1. 同步代码块
```java
synchronized(对象){//得到对象的锁，才能操作同步代码
	//需要被同步代码
}
```

2. synchronized还可以放在方法声明中，表示整个方法为同步方法
```java
public synchronized void m (String name){
	//需要被同步的代码
}
```


#### 互斥锁
1. Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。
2. 每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。
3. 关键字 `synchronized` 来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该`对象`在任一时刻只能由一个线程访问
4. 同步的局限性：导致程序的执行效率要降低
5. 同步方法（非静态）的锁可以是this，也可以是其他对象(要求是同一个对象)
6. 同步方法（静态的）的锁为当前类本身



### 线程的死锁
多个线程都占用了对方的锁资源，但不肯相让，导致了死锁,在编程是一定要避免死锁的发生。

**产生死锁的四个必要条件：**
（1） 互斥：一个资源每次只能被一个进程使用。
（2） 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不可剥夺：进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。

例子：
```java
//下面业务逻辑的分析  
//1. 如果flag 为 T, 线程A 就会先得到/持有 o1 对象锁, 然后尝试去获取 o2 对象锁  
//2. 如果线程A 得不到 o2 对象锁，就会Blocked  
//3. 如果flag 为 F, 线程B 就会先得到/持有 o2 对象锁, 然后尝试去获取 o1 对象锁  
//4. 如果线程B 得不到 o1 对象锁，就会Blocked  
if (flag) {  
    synchronized (o1) {//对象互斥锁, 下面就是同步代码  
        System.out.println(Thread.currentThread().getName() + " 进入1");  
        synchronized (o2) { // 这里获得li对象的监视权  
            System.out.println(Thread.currentThread().getName() + " 进入2");  
        }  
          
    }  
} else {  
    synchronized (o2) {  
        System.out.println(Thread.currentThread().getName() + " 进入3");  
        synchronized (o1) { // 这里获得li对象的监视权  
            System.out.println(Thread.currentThread().getName() + " 进入4");  
        }  
    }  
}
```



### 释放锁

#### 释放锁的操作
1. 当前线程的同步代码块、同步方法中`执行结束`
2. 当前线程在同步代码块、同步方法中`遇到break、return`
3. 当前线程在同步代码块、同步方法中`出现了未处理的Error或Exception，导致异常结束`
4. 当前线程在同步代码块、同步方法中`执行了线程对象的wait()方法，当前线程暂停，并释放锁`

#### 不会释放锁的操作
1. 线程执行同步代码块或同步方法时，程序调用`Thread.sleep()`、`Thread.yield()`方法暂停当前线程的执行，不会释放锁
2. 线程执行同步代码块时，其他线程调用了该线程的`suspend()`方法将该线程挂起，该线程不会释放锁。提示：应尽量避免使用`suspend()`和`resume()`来控制线程，方法过时，不再推荐使用










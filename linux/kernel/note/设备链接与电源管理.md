# 设备链接与电源管理


## Device links 设备链接

默认情况下，驱动程序核心仅强制实施设备层次结构中基于父子关系的设备之间的依赖关系：在挂起、恢复或关闭系统时，设备会根据这种关系排序，即子设备始终在其父设备之前挂起，而父设备始终在其子设备之前恢复。

有时，除了简单的父子关系之外，还需要表示`设备之间的依赖关系`，例如兄弟设备之间的依赖关系，并让驱动程序核心自动处理这些关系。

其次，默认情况下，驱动程序核心`不会强制实施任何驱动程序存在依赖项`，也就是说，一个设备不必在另一个设备能够正确探测或正常运行之前绑定到驱动程序。

通常这两种依赖类型会同时出现，因此一个设备在驱动程序存在性方面，以及在挂起/恢复和关机顺序方面，都依赖于另一个设备。

设备链接允许在驱动程序核心中表示此类依赖关系。

在其`标准或托管形式`中，设备链接结合了两种依赖类型：它保证了` “提供者” 设备与其 “使用者” 设备之间正确的挂起/恢复和关闭顺序`，并且保证了`提供者上存在驱动程序`。在提供者绑定到驱动程序之前，不会探测使用者设备，并且在提供者解除绑定之前，使用者设备会先解除绑定。

当`驱动程序在供应端的存在与否无关紧要`，且仅需纠正挂起/恢复和关机顺序时，设备链路可以简单地使用 `DL_FLAG_STATELESS` 标志进行设置。换句话说，在供应端强制要求驱动程序存在是可选的。

另一个可选功能是*运行时电源管理（PM）集成*：在添加设备链接时设置`DL_FLAG_PM_RUNTIME`标志，可指示PM核心在使用者运行时恢复期间，随时运行时恢复供应者并使其保持活动状态。



### 用法

1. 最早可以添加设备链接的**时间点**是，**在为供应方调用`device_add()`且为使用方调用`device_initialize()`之后**。

2. 稍后添加它们是合法的，但**必须注意确保系统保持一致状态**：例如，在挂起/恢复转换过程中不能添加设备链接，因此，要么使用 `lock_system_sleep()` 防止开始此类转换，要么从保证`不会与挂起/恢复转换并行运行`的函数中`添加设备链接`，例如从设备 `->probe` 回调或启动时的PCI特殊处理中添加。

3. 另一个不一致状态的例子是，一个设备链接表示驱动程序存在依赖关系，但却是在供应商尚未开始探测时，从使用者的->probe回调中添加的：如果驱动程序核心能更早知道该设备链接，它一开始就不会探测使用者。因此，`使用者有责任在添加链接后检查供应商是否存在，若不存在则推迟探测`。[请注意，在供应商仍在探测时，从使用者的->probe回调中创建链接是有效的，但使用者必须知道在创建链接时供应商已能正常工作（例如，如果使用者刚刚获取了一些资源，而如果当时供应商无法正常工作，这些资源就不可用，就是这种情况）。]

4. 如果在供应方或消费方驱动程序的 `DL_FLAG_STATELESS` 回调中添加了设置了 `DL_FLAG_STATELESS` 的设备链接（即无状态设备链接），**为保持一致性，通常会在其 `->remove` 回调中删除该链接**。这样，如果驱动程序被编译为模块，设备链接会在模块加载时添加，并在卸载时有序删除。适用于添加设备链接的相同限制（例如，排除并行挂起/恢复转换）同样适用于删除操作。由驱动程序核心管理的设备链接会由其自动删除。

5. 添加设备链接时可以指定几个标志，其中两个已在上面提到过：**`DL_FLAG_STATELESS` 表示不需要依赖驱动程序的存在（但需要正确的挂起/恢复和关机顺序）**，**`DL_FLAG_PM_RUNTIME` 表示需要运行时电源管理集成**。

6. 另外两个标志专门针对从使用者的`->probe`回调中添加设备链路的用例：可以**指定`DL_FLAG_RPM_ACTIVE`，以便在运行时恢复供应方，并在使用者运行时挂起之前防止其挂起**。**`DL_FLAG_AUTOREMOVE_CONSUMER`会导致在使用者探测失败或稍后取消绑定时自动清除设备链路**。

7. 同样，当通过供应商的`->probe`回调添加设备链路时，**`DL_FLAG_AUTOREMOVE_SUPPLIER`会导致在供应商探测失败或稍后解除绑定时自动清除该设备链路。**

8. 如果既未设置`DL_FLAG_AUTOREMOVE_CONSUMER`，也未设置`DL_FLAG_AUTOREMOVE_SUPPLIER`，则**在驱动程序绑定到提供者设备后，可使用`DL_FLAG_AUTOPROBE_CONSUMER`请求驱动程序核心自动为链接上的使用者驱动程序探测驱动程序**。

9. 不过请注意，`DL_FLAG_AUTOREMOVE_CONSUMER`、`DL_FLAG_AUTOREMOVE_SUPPLIER` 或 `DL_FLAG_AUTOPROBE_CONSUMER` 与 `DL_FLAG_STATELESS` 的任何**组合均无效，不能使用**。



### 限制

驱动程序开发者应该注意，对于**托管设备链接**而言，如果存在驱动存在依赖关系（即在添加链接时未指定`DL_FLAG_STATELESS`），**可能会导致对使用者的探测被无限期推迟**。如果要求使用者在达到某个初始化调用级别之前进行探测，这就会成为一个问题。更糟糕的是，如果供应方驱动程序被列入黑名单或缺失，使用者将永远不会被探测。

此外，**托管设备链接不能直接删除**。当根据`DL_FLAG_AUTOREMOVE_CONSUMER`和`DL_FLAG_AUTOREMOVE_SUPPLIER`标志判断不再需要它们时，由驱动程序核心将其删除。但是，无状态设备链接（即设置了`DL_FLAG_STATELESS`的设备链接）预期由调用`device_link_add()`添加它们的一方借助`device_link_del()`或`device_link_remove()`将其删除。

将 `DL_FLAG_RPM_ACTIVE` 与 `DL_FLAG_STATELESS` 一同传递给 `device_link_add()`，可能会导致在随后调用 `device_link_del()` 或 `device_link_remove()` 删除其返回的设备链路后，供应设备的电源管理（PM）运行时使用计数器仍不为零。如果针对同一"消费者 - 供应者"对连续两次调用 `device_link_add()`，且在这两次调用之间未删除链路，就会出现这种情况。在这种情况下，若在尝试删除链路时允许供应者的 PM 运行时使用计数器下降，可能会导致在消费者仍处于 PM 运行时活动状态时供应者被挂起，这必须避免。[为解决此限制，在 `device_link_add()` 与 `device_link_del()` 或 `device_link_remove()` 调用之间，**只需让消费者运行时至少挂起一次**，或者在禁用 PM 运行时的情况下对其调用 `pm_runtime_set_suspended()` 即可。]

有时驱动程序依赖于可选资源。当这些资源不存在时，它们能够以降级模式（功能集或性能降低）运行。例如，SPI 控制器可以使用 DMA 引擎，也可以在 PIO 模式下工作。控制器可以在探测时确定可选资源是否存在，但如果资源不存在，就无法知道它们在不久的将来是否会可用（由于供应商驱动程序的探测），或者永远不可用。因此，无法确定是否推迟探测。可以在探测后可选资源可用时通知驱动程序，但这对驱动程序来说成本很高，因为基于此类资源的可用性在运行时在操作模式之间切换，比基于探测延迟的机制要复杂得多。无论如何，**可选资源不在设备链接的范围内**。



### 示例

- 存在一个内存管理单元（MMU）设备和一个总线主控设备，二者处于同一电源域。MMU为总线主控设备实现直接内存访问（DMA）地址转换，只要总线主控设备处于活动状态，MMU就应在运行时恢复并保持活动。总线主控设备的驱动程序不得在MMU绑定之前进行绑定。为实现这一点，从总线主控设备（使用者）到MMU设备（提供者）添加了一个集成了运行时电源管理（runtime PM）的设备链接。就运行时电源管理而言，其效果等同于MMU是主控设备的父设备。
  
  事实上，这两个设备共享相同的电源域，通常意味着应使用 `struct dev_pm_domain` 或 `struct generic_pm_domain`。然而，这两个设备并非仅仅碰巧共享一个电源开关的独立设备，而是MMU设备为总线主控设备服务，没有总线主控设备，MMU设备就毫无用处。设备链接在设备之间创建了一种虚拟的层次关系，因此更为合适。

- 一个雷电主机控制器包含若干个PCIe热插拔端口以及一个用于管理PCIe交换机的NHI设备。系统从睡眠状态恢复时，NHI设备需要在热插拔端口恢复之前，重新建立与所连接设备的PCI隧道(NHI 设备是热插拔端口的 “服务提供者”) 。如果热插拔端口是NHI的子设备，这种恢复顺序会由电源管理核心自动实施，但遗憾的是，它们是“姑婶”关系（非直接父子关系）。解决方案是添加从热插拔端口（使用者）到NHI设备（提供者）的设备链接。对于此用例，驱动存在依赖性并非必要。

- 在混合图形笔记本电脑中，独立显卡通常配备用于HDMI/DP音频的HDA控制器。在设备层次结构中，HDA控制器与VGA设备是同级关系，但它们共享相同的电源域，并且只有在VGA设备连接了HDMI/DP显示器时，才需要HDA控制器。从HDA控制器（消费者）到VGA设备（供应商）的设备链接恰当地体现了这种关系。

- `ACPI`允许通过`_DEP`对象定义设备启动顺序。一个典型的例子是，当一个设备上的ACPI电源管理方法通过I2C访问来实现，并且需要特定的I2C控制器存在且正常工作，才能使相关设备的电源管理正常运行。

- 在一些片上系统（SoC）中，显示、视频编解码器和视频处理IP核，对负责突发访问及压缩/解压缩的透明内存访问IP核存在功能依赖。



### 替代方案

- 一个`struct dev_pm_domain`可用于覆盖总线、类或设备类型回调。它旨在用于共享单个开/关开关的设备，不过它并不保证特定的挂起/恢复顺序，这需要单独实现。它本身也不会跟踪相关设备的运行时电源管理状态，也不会仅在所有设备都处于运行时挂起状态时才关闭电源开关。此外，它不能用于强制特定的关机顺序或驱动程序存在依赖关系。

- 结构体`generic_pm_domain`比设备链接要复杂得多，它不支持关机顺序或驱动存在依赖关系。它也不能在ACPI系统上使用。



### 实现原理

设备层次结构，顾名思义，它是一棵树，一旦添加了设备链接，就会变成一个*有向无环图*。

在挂起/恢复期间，这些设备的排序由`dpm_list`决定。在关机期间，其排序由`devices_kset`决定。如果不存在设备链接，这两个列表就是设备树的扁平化一维表示，这样一来，一个设备会排在其所有祖先设备之后。这是通过自上而下遍历`ACPI命名空间`或`OpenFirmware设备树`，并在发现设备时将其追加到列表中来实现的。

一旦添加了设备链接，这些列表需要满足额外的约束条件，即设备会`递归地置于其所有供应商之后`。为确保这一点，在添加设备链接时，消费者及其下方的整个子图（消费者的所有子项和消费者）会被移至列表末尾。（从 `device_link_add()` 调用 `device_reorder_to_tail()`。）

为**防止在图中引入依赖循环**，在添加设备链路时会验证供应商不依赖于消费者或消费者的任何子级或消费者。（从`device_link_add()`调用`device_is_dependent()`。）如果违反该约束，`device_link_add()`将返回`NULL`，并记录一条`WARNING`。

值得注意的是，这也会**阻止从父设备向子设备添加设备链接**。不过，反过来是允许的，即从子设备到父设备的设备链接。由于驱动程序核心已经保证了父子设备之间正确的挂起/恢复和关机顺序，因此只有在需要额外的驱动程序存在依赖关系时，这样的设备链接才有意义。在这种情况下，驱动程序作者应该仔细权衡设备链接是否确实适合该目的。一种更合适的方法可能是*简单地使用延迟探测*，或者添加一个设备标志，使得父驱动程序在子驱动程序之前被探测。



### 状态机

```c
// include/linux/device.h
enum device_link_state {
	DL_STATE_NONE = -1,				// 未对驱动程序的存在进行跟踪
	DL_STATE_DORMANT = 0,			// 供应商/消费者驱动程序均不存在 (DORMANT: 休眠的；蛰伏的；暂停活动的)
	DL_STATE_AVAILABLE,				// 供应商驱动程序已存在，但使用者驱动程序不存在。
	DL_STATE_CONSUMER_PROBE,		// 消费者正在探测（供应商驱动程序已存在）。
	DL_STATE_ACTIVE,				// 供应商驱动程序和使用者驱动程序均已存在。
	DL_STATE_SUPPLIER_UNBIND,		// 供应商驱动程序正在解除绑定。
};
```

**状态机切换**

```
                .=============================.
                |                             |
                v                             |
DORMANT <=> AVAILABLE <=> CONSUMER_PROBE => ACTIVE
   ^                                          |
   |                                          |
   '============ SUPPLIER_UNBIND <============'
```

- 设备链路的初始状态由`device_link_add()`根据供应商和消费者端的驱动程序存在情况自动确定。如果在探测任何设备之前创建链路，则将其设置为`DL_STATE_DORMANT`。
- 当一个供应设备绑定到驱动程序时，其使用者的链接将进入 `DL_STATE_AVAILABLE` 状态。（从 `driver_bound()` 调用 `device_links_driver_bound()`。）
- 在探测消费端设备之前，通过检查消费端设备不在等待供应商列表中，并且检查到供应商的链路处于 `DL_STATE_AVAILABLE` 状态，来验证供应商驱动程序是否存在。链路状态会更新为 `DL_STATE_CONSUMER_PROBE`。（从 `really_probe()` 调用 `device_links_check_suppliers()`。）这可防止供应商解除绑定。（从 `device_links_unbind_consumers()` 调用 `wait_for_device_probe()`。）
- 如果探测失败，到供应商的链接将恢复为 `DL_STATE_AVAILABLE`。（从 `really_probe()` 调用 `device_links_no_driver()`。）
- 如果探测成功，到供应商的链接将进入`DL_STATE_ACTIVE`状态。（从`driver_bound()`调用`device_links_driver_bound()`。）
- 当消费者的驱动程序随后被移除时，到供应商的链接将恢复为 `DL_STATE_AVAILABLE`。（从 `device_links_driver_cleanup()` 调用 `__device_links_no_driver()`，而 `device_links_driver_cleanup()` 又从 `__device_release_driver()` 调用。）
- 在移除供应商驱动程序之前，未绑定到驱动程序的消费者链接会更新为 `DL_STATE_SUPPLIER_UNBIND`。（从 `device_links_busy()` 调用 `__device_release_driver()`。）这会阻止消费者进行绑定。（从 `really_probe()` 调用 `device_links_check_suppliers()`。）已绑定的消费者会从其驱动程序中释放；正在探测的消费者会等待直到完成。（从 `__device_release_driver()` 调用 `device_links_unbind_consumers()`。）一旦所有与消费者的链接都处于 `DL_STATE_SUPPLIER_UNBIND` 状态，就会释放供应商驱动程序，并且链接会恢复到 `DL_STATE_DORMANT`。（从 `__device_release_driver()` 调用 `device_links_driver_cleanup()`。）




### API

```c
// include/linux/device.h
/* Device links interface. */
struct device_link *device_link_add(struct device *consumer,
				    struct device *supplier, u32 flags);
void device_link_del(struct device_link *link);
void device_link_remove(void *consumer, struct device *supplier);
```



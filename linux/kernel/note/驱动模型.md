# 驱动模型

Refer:

- [Driver implementer’s API guide — The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/driver-api/index.html)
- [Driver Model — The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/driver-api/driver-model/index.html)


## Device Driver 绑定

驱动程序绑定是将设备与能够控制它的设备驱动程序相关联的过程。通常由`总线驱动程序来处理这个问题`，因为一直存在特定于总线的结构来表示设备和驱动程序。有了通用的设备和设备驱动程序结构，大部分绑定都可以使用通用代码来完成。

### 1. Bus

`Bus` 包含:
- `Device`: 由 `device_register` 插入 Bus 列表
- `Driver`: 由 `driver_register` 插入 Bus 列表

总线类型结构包含系统中该总线类型上所有设备的列表。

当为某个设备调用device_register时，该设备会被插入到此列表的末尾。

总线对象还包含该总线类型所有驱动程序的列表。

当为某个驱动程序调用driver_register时，该驱动程序会被插入到此列表的末尾。这两个事件会触发驱动程序绑定。


### 2. device_register

当`添加新设备`时，会遍历总线的驱动程序列表，以找到一个支持该设备的驱动程序。

为了确定这一点，设备的设备ID必须与驱动程序支持的设备ID之一相匹配。比较ID的格式和语义因总线而异。

与其尝试推导复杂的状态机和匹配算法，不如由总线`驱动程序`提供一个`回调函数`(`.match`)，将设备与驱动程序的ID进行比较。如果找到匹配项，总线返回1；否则返回0。

```
int match(struct device * dev, struct device_driver * drv);
```

如果找到匹配项，设备的驱动程序字段将`设置为该驱动程序`，并且会`调用驱动程序的探测回调函数`(`.probe`)。这使驱动程序有机会验证其`是否真正支持该硬件`，以及该`硬件是否处于工作状态`。


### 3. Device Class

在成功完成`探测`(`.probe`)后，`设备`会向其`所属的类`注册。设备驱动程序只属于一个类，这个类在`驱动程序`的`devclass`字段中设置。调用`devclass_add_device`函数在类中枚举设备，并通过类的`register_dev`回调函数`实际向该类注册设备`。


### 4. Driver

当一个驱动程序附加到一个设备时，该设备会被插入到驱动程序的设备列表中。


### 5. sysfs

在`总线`的“devices”目录中会创建一个`符号链接`，它指向`物理层级结构中设备的目录`。

在`驱动程序`的“devices”目录中会创建一个`符号链接`，它指向`物理层级结构中设备的目录`。

在`类的目录`中会为该设备创建一个目录。在该目录中会创建一个`符号链接`，它指向该设备在`sysfs树中的物理位置`。

可以在设备的`物理目录`中创建一个`符号链接`，该符号链接可以指向其`类目录`，也可以指向`该类的顶级目录`。还可以创建一个符号链接指向其`驱动程序目录`。（尽管目前尚未实现，上面的总线、驱动程序都有链接到物理位置，单向是实现了，双向得看Linux版本history什么时候实现）


### 6. driver_register

`添加新驱动程序`时的过程几乎相同。会`遍历总线`上的设备列表以找到匹配项。`已拥有驱动程序的设备将被跳过`。会遍历所有设备，以便尽可能多地将设备绑定到该驱动程序。


### 7. Removal

当一个`设备被移除`时，其引用`计数最终会归零`。当引用计数为零时，会`调用驱动程序的移除回调函数`。该设备会从驱动程序的设备列表中移除，并且`驱动程序的引用计数会减一`。两者之间的`所有符号链接都会被移除`。

当`移除一个驱动程序`时，会`遍历它所支持的设备列表`，并`为每个设备调用驱动程序的移除回调函数`。设备会从该列表中移除，同时符号链接也会被删除。



## Bus Type 结构

### Bus 结构体定义


```c
// include/linux/device.h
struct bus_type {
	const char		*name;              // bus 名
	const char		*dev_name;          // 用于子系统枚举设备的表达式，如 `sprint(buffer, "foo%u", dev->id)`
	struct device		*dev_root;      // 用作父(设备)的默认设备。
	const struct attribute_group **bus_groups;      // 总线的默认属性。
	const struct attribute_group **dev_groups;      // 总线上设备的默认属性。
	const struct attribute_group **drv_groups;      // 总线上设备驱动的默认属性。

	int (*match)(struct device *dev, struct device_driver *drv);		// 驱动和设备的匹配函数：每当为该总线添加新设备或驱动程序时，可能会多次调用此函数。如果给定的驱动程序可以处理给定的设备，则应返回一个正值，否则返回零。如果无法确定驱动程序是否支持该设备，它也可能返回错误代码。如果返回 -EPROBE_DEFER ，则会将该设备排队等待延迟探测。
	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);		// 当设备添加、移除或发生其他一些会生成 uevent 的情况时调用，以便添加环境变量。uevent 是 Linux 内核中用于实现内核空间与用户空间通信的一种机制，主要用于通知用户空间关于硬件设备的状态变化（如设备插入、移除、属性变更等）。它是 Linux 设备模型（Device Model）的重要组成部分，属于 热插拔事件（Hotplug Events） 的一种实现方式。
	int (*probe)(struct device *dev);			// 当有`新设备或驱动程序`添加到该总线时调用此函数，并回调特定驱动程序的探测函数以初始化匹配的设备。
	int (*remove)(struct device *dev);			// 当`设备`从该总线移除时调用。
	void (*shutdown)(struct device *dev);		// 在关机时调用，以使`设备进入静止状态`

	int (*online)(struct device *dev);			// 在设备离线后，调用此函数使设备重新上线。
	int (*offline)(struct device *dev);			// 调用此函数以使设备离线以便热移除。可能会失败。

	int (*suspend)(struct device *dev, pm_message_t state);		// 当此总线上的设备想要进入睡眠模式时调用。
	int (*resume)(struct device *dev);		// 调用此函数可使该总线上的设备退出睡眠模式。

	int (*num_vf)(struct device *dev);		// 调用此函数以查明该总线上的设备支持多少个`虚拟函数`。

	int (*dma_configure)(struct device *dev);		// 用于设置此总线上某个设备的直接内存访问（DMA）配置。

	const struct dev_pm_ops *pm;		// 此总线的电源管理操作，回调特定设备驱动程序的电源管理操作。

	const struct iommu_ops *iommu_ops;		// 该总线上特定于IOMMU的操作，用于将IOMMU驱动程序实现附加到总线上，并允许驱动程序执行总线特定的设置。

	struct subsys_private *p;			// 驱动程序核心的私有数据，只有驱动程序核心可以操作此数据。
	struct lock_class_key lock_key;		// 供锁验证器使用的锁类密钥

	bool need_parent_lock;				// 当探测或移除该总线上的设备时，设备核心是否应锁定该设备的父设备。
};

extern int __must_check bus_register(struct bus_type *bus);
```


### 声明一种 Bus

内核中的每种总线类型（PCI、USB 等）都应该声明一个这种类型的静态对象。它们必须初始化name字段，并且可以选择初始化匹配回调函数：

```c
// drivers/pci/pci-driver.c
struct bus_type pci_bus_type = {
	.name = "pci",
	.match = pci_bus_match,
	...
};
EXPORT_SYMBOL(pci_bus_type);
```

该结构体应通过头文件导出给驱动程序：

```c
extern struct bus_type pci_bus_type;
```


### 注册一种 Bus

当一个总线驱动程序初始化时，它会调用 `bus_register`。这会初始化总线对象中的其余字段，并将其插入到全局总线类型列表中。一旦总线对象注册完成，总线驱动程序就可以使用其中的字段。

```c
// include/linux/device.h
extern int __must_check bus_register(struct bus_type *bus);

// drivers/base/bus.c
int bus_register(struct bus_type *bus){}
```


### Bus 相关回调函数

#### match()

设备ID结构的格式以及比较它们的语义本质上是特定于总线的。

`驱动程序`通常会声明一个`数组`，该数组包含它们`所支持的`、位于`特定于总线`的`驱动程序结构`中的`设备的设备ID`。

匹配回调的目的是`让总线有机会通过将驱动程序支持的设备ID与特定设备的设备ID进行比较`，来`确定特定驱动程序是否支持特定设备`，同时又不牺牲总线特定的功能或类型安全性。

当一个`驱动程序`在`总线上注册时`，会遍历总线的设备列表，并对每个`没有关联驱动程序`的设备调用匹配回调函数。

```
int (*match)(struct device *dev, struct device_driver *drv);		// return > 0 if matched else <=0, <0 is error code
```


### Bus 设备与驱动程序列表

设备列表和驱动程序列表旨在取代许多总线维护的本地列表。

它们分别是结构体`设备列表`和结构体设备`驱动程序列表`。`总线驱动程序`可随意使用这些列表，但可能需要`转换为特定于总线的类型`。

LDM (Linux Device Model) 核心提供了用于遍历每个列表的辅助函数：

```c
// include/linux/device.h
// drivers/base/bus.c
int bus_for_each_dev(struct bus_type * bus, struct device * start,
                     void * data, int (*fn)(struct device *, void *));

int bus_for_each_drv(struct bus_type * bus, struct device_driver * start,
                     void * data, int (*fn)(struct device_driver *, void *));

/*
@bus：表示要遍历的总线类型。
@start: 表示迭代开始的设备/驱动。如果为NULL，则从列表的第一个设备/驱动开始。
@data：这是自定义的传递给回调函数的数据，可以是任何类型的信息，用于回调函数的处理。
@fn：这是对每个设备调用的回调函数。该函数应该接受一个设备/驱动指针和@data作为参数。

对每个设备调用@fn函数。如果@fn返回`非零值`，迭代将终止，并返回该值。这允许回调函数控制迭代过程，例如，如果找到特定设备，可以提前终止迭代。
*/
```

这些辅助函数会遍历相应的列表，并为列表中的每个设备或驱动程序调用回调函数。

所有的列表访问操作都会通过获取总线锁（当前为读锁）来进行同步。

在调用回调函数之前，列表中每个对象的引用计数会增加；在获取下一个对象之后，引用计数会减少。`调用回调函数时不会持有锁`。这意味着如果调用者需要保留设备信息，必须在回调函数中增加设备的引用计数，以防止设备在迭代结束前被释放。



### Bus 与 sysfs

有一个名为“bus”的顶级目录。

每个总线在总线目录中都有一个目录，以及两个默认目录：

```
/sys/bus/pci/
|-- devices
`-- drivers
```

向总线注册的驱动程序会在总线的驱动程序目录中获得一个目录：

```
/sys/bus/pci/
|-- devices
`-- drivers
    |-- Intel ICH
    |-- Intel ICH Joystick
    |-- agpgart
    `-- e100
```

在该类型总线上发现的每个设备，都会在总线的设备目录中创建一个符号链接，指向`物理层级结构`中该设备的目录：

```
/sys/bus/pci/
|-- devices
|   |-- 00:00.0 -> ../../../devices/pci0/00:00.0
|   |-- 00:01.0 -> ../../../devices/pci0/00:01.0
|   `-- 00:02.0 -> ../../../devices/pci0/00:02.0
`-- drivers
```


### Bus Attribute 属性导出

Bus 导出属性到用户空间 的 结构定义：

```c
// include/linux/device.h
struct bus_attribute {
	struct attribute	attr;
	ssize_t (*show)(struct bus_type *bus, char *buf);
	ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
};

// include/linux/sysfs.h
struct attribute {
	const char		*name;		// sysfs中的文件名
	umode_t			mode;		// sysfs中的文件的权限
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	bool			ignore_lockdep:1;
	struct lock_class_key	*key;
	struct lock_class_key	skey;
#endif
};
```

总线驱动程序可以使用`BUS_ATTR_RW`宏导出属性，该宏的工作方式与设备的`DEVICE_ATTR_RW`宏类似。例如，像这样的定义：

```c
static BUS_ATTR_RW(debug);
```

等同于声明：

```c
static bus_attribute bus_attr_debug;
```

然后，可以使用以下命令，在`总线`的`sysfs`目录中添加和删除该属性：

```c
// include/linux/device.h
// drivers/base/bus.c
int bus_create_file(struct bus_type *, struct bus_attribute *);
void bus_remove_file(struct bus_type *, struct bus_attribute *);
```



## Device Driver 设计模式

### 状态容器

虽然内核包含一些设备驱动程序，这些驱动程序假定在某个特定系统上只会被探测（probe()）一次（单例），但通常会假定驱动程序绑定的设备会以`多个实例`的形式出现。这意味着`probe()函数`和`所有回调函数`都需要是`可重入的`。

实现这一点最常见的方法是使用`状态容器设计模式`。它通常具有以下形式：

```c
struct foo {
    spinlock_t lock; /* Example member， 不用太过关注 */
    (...)
};

static int foo_probe(...)
{
    struct foo *foo;

    foo = devm_kzalloc(dev, sizeof(*foo), GFP_KERNEL);  // 设备关联内存分配函数，属于 devm_ 系列函数（Device-Managed Resources）。它分配的内存会被注册到设备 dev 的资源管理列表中，内核会自动跟踪这些内存。当设备 dev 被卸载（如驱动移除）或销毁时，内核会自动释放所有与该设备绑定的内存，无需驱动开发者手动调用 kfree。避免内存泄漏。
    if (!foo)
        return -ENOMEM;
    spin_lock_init(&foo->lock);
    (...)
}
```

每次调用probe()时，这将在内存中创建一个struct foo实例。这是`此设备驱动程序实例`的状态容器。当然，随后有必要始终将此状态实例传递给所有需要访问该状态及其成员的函数。

例如，如果驱动程序正在注册一个中断处理程序，你可以像这样传递一个指向 `struct foo` 的指针：

```c
static irqreturn_t foo_handler(int irq, void *arg)
{
    struct foo *foo = arg;
    (...)
}

static int foo_probe(...)
{
    struct foo *foo;

    (...)
    ret = request_irq(irq, foo_handler, 0, "foo", foo);
}
```

这样，在中断处理程序中，你总能获得指向foo正确实例的指针。



### container_of() - 获取结构体成员所在的结构体(容器)指针

参照上述的 “状态容器” 举例，添加一项中断卸载任务时：

```c
struct foo {
    spinlock_t lock;
    struct workqueue_struct *wq;  // 不能使用这种指针类型的成员来进行container_of定位foo结构体地址
    struct work_struct offload;
    (...)
};

static void foo_work(struct work_struct *work)
{
    struct foo *foo = container_of(work, struct foo, offload);

    (...)
}

static irqreturn_t foo_handler(int irq, void *arg)
{
    struct foo *foo = arg;

    queue_work(foo->wq, &foo->offload);
    (...)
}

static int foo_probe(...)
{
    struct foo *foo;

    foo->wq = create_singlethread_workqueue("foo-wq");
    INIT_WORK(&foo->offload, foo_work);
    (...)
}
```

对于高精度定时器（hrtimer）或类似的东西，其设计模式是相同的，它们将在回调函数中返回`单个参数`，该参数是指向`结构体成员的指针`。

`container_of()` 的作用是，使用标准C中的 `offsetof()` 宏，通过简单的减法运算，从指向成员的指针`获取`指向包含该成员的`结构体的指针`，这使得（代码）能够实现类似于`面向对象`的行为。请注意，被包含的`成员不能是指针`，而`必须是实际的成员`，此方法才能奏效。container_of 实际上是一个宏定义。

通过这种方式，我们避免了使用指向结构体`foo *instance`的全局指针，同时仍将传递给foo_work工作函数的参数数量保持为单个指针。



## Device 结构

### Device 结构体定义

```c
// include/linux/device.h
struct device {
	struct kobject kobj;			// 所属的内核对象，一个顶层抽象类，其他类从中派生而来。
	struct device		*parent;	// 该设备的“父”设备，即它所连接的设备。在大多数情况下，父设备是某种总线或主机控制器。如果父设备为NULL，则该设备是顶级设备，这通常不是你想要的。

	struct device_private	*p;		// 保存*设备驱动*核心部分的私有数据。详细信息请参阅结构体 device_private 的注释。

	const char		*init_name; 	// 设备的初始名称。
	const struct device_type *type;	// 设备的类型。这用于识别设备类型并携带特定类型的信息。

	struct bus_type	*bus;			// 所在的总线的类型
	struct device_driver *driver;	// 被分配的**设备驱动**
	void		*platform_data;		// 特定于设备的平台数据，设备核心不应该接触它。
	void		*driver_data;		// 用于驱动程序特定信息的私有指针。驱动数据，通过 dev_set_drvdata/dev_get_drvdata 设置和获取
#ifdef CONFIG_PROVE_LOCKING
	struct mutex		lockdep_mutex;
#endif
	struct mutex		mutex;		// 用于同步对其驱动程序调用的互斥锁。mutex to synchronize calls to its driver.

	struct dev_links_info	links;	// 该设备供应商和消费者的链接。
	struct dev_pm_info	power;		// 用于设备电源管理。详情请参阅设备电源管理基础。
	struct dev_pm_domain	*pm_domain;		// 提供在系统挂起、休眠、系统恢复以及运行时电源管理转换期间执行的回调，同时提供子系统级和驱动程序级回调。

#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
	struct irq_domain	*msi_domain;	/* 高版本移除 */
#endif
#ifdef CONFIG_ENERGY_MODEL;
    struct em_perf_domain   *em_pd; /* 设备的能量模型性能域， 高版本，5.10无 */
#endif;
#ifdef CONFIG_PINCTRL
	struct dev_pin_info	*pins;		/* 对于设备引脚管理。详情请参阅 PINCTRL（引脚控制）子系统。 */
#endif
#ifdef CONFIG_GENERIC_MSI_IRQ
	raw_spinlock_t		msi_lock;
	struct list_head	msi_list;
#endif

	struct dev_msi_info     msi;	// MSI相关数据

#ifdef CONFIG_ARCH_HAS_DMA_OPS;		// 高版本添加的编译选项，5.10无
	const struct dma_map_ops *dma_ops;	/* 此设备的DMA映射操作。 */
#endif;
	u64		*dma_mask;				// DMA掩码（如果设备支持DMA）。
	u64		coherent_dma_mask;/* Like dma_mask, but for
					     alloc_coherent mappings as
					     not all hardware supports
					     64 bit addresses for consistent
					     allocations such descriptors. */ 
						 			// 与 `dma_mask` 类似，但用于 `alloc_coherent` 映射，因为并非所有硬件都支持用于一致性分配的 64 位地址这类描述符。
	u64		bus_dma_mask;	// 高版本移除，5.10有。上游桥接器或总线的掩码（机制），其施加的直接内存访问（DMA）限制小于设备自身支持的限制。
	u64 bus_dma_limit;		// 高版本新增，5.10无。上游桥接器或总线的限制，该限制所施加的直接内存访问（DMA）限制比设备自身支持的限制要小。
	unsigned long	dma_pfn_offset;	// DMA 内存范围相对于 RAM 的偏移量。5.10有，高版本6.x?无
	const struct bus_dma_region *dma_range_map;	// 高版本新增，5.10无。相对于随机存取存储器（RAM）的直接内存访问（DMA）内存范围映射。dma在ram上的内存映射范围。
	struct device_dma_parameters *dma_parms;	// 低级驱动程序可以设置这些参数，以便向IOMMU代码说明段限制。

	struct list_head	dma_pools;	// 直接内存访问（DMA）池（如果设备支持直接内存访问）。

#ifdef CONFIG_DMA_DECLARE_COHERENT
	struct dma_coherent_mem	*dma_mem; 	/* 用于一致性内存覆盖的内部设置。 */
#endif
#ifdef CONFIG_DMA_CMA
	struct cma *cma_area;				/* 用于DMA分配的连续内存区域 */
#endif
#ifdef CONFIG_SWIOTLB;
    struct io_tlb_mem *dma_io_tlb_mem;	/* 高版本新增，5.10无。软件输入输出转换后备缓冲器分配器。 驱动程序请勿使用。 */
#endif;
#ifdef CONFIG_SWIOTLB_DYNAMIC;
    struct list_head dma_io_tlb_pools;	/* 高版本新增，5.10无。临时软件I/O转换后备缓冲区（swiotlb）内存池列表。 */
    spinlock_t dma_io_tlb_lock;			/* 高版本新增，5.10无。保护对活动池列表的更改。 */
    bool dma_uses_io_tlb;				/* 高版本新增，5.10无。如果设备使用了软件IO TLB，则为true。 */
#endif;

	/* arch specific additions */
	struct dev_archdata	archdata;		// 用于特定架构的补充内容。

	struct device_node	*of_node; 		// 关联的设备树节点。
	struct fwnode_handle	*fwnode; 	// 平台固件提供的关联设备节点。

#ifdef CONFIG_NUMA
	int		numa_node;					/* 该设备靠近的NUMA节点。 */
#endif
	dev_t			devt;				// 用于创建sysfs“dev”。
u32			id;							// 设备实例
	spinlock_t		devres_lock;		// 用于保护设备资源的自旋锁。
	struct list_head	devres_head;	// 设备的资源列表。

	struct class		*class;				// 设备的类别。
	const struct attribute_group **groups;	// 可选属性组。

	void	(*release)(struct device *dev);	// 所有引用消失后释放设备的回调函数。这应由设备的分配器（即发现该设备的总线驱动程序）进行设置。

	struct iommu_group	*iommu_group;		// 设备所属的IOMMU组。
	struct iommu_fwspec	*iommu_fwspec;		// 固件提供的特定于 IOMMU 的属性
	struct iommu_param	*iommu_param;		// 高版本移除，5.10有。每个设备的通用 IOMMU 运行时数据
	struct dev_iommu        *iommu;			// 高版本新增，5.10无。每个设备通用的IOMMU运行时数据

	bool			offline_disabled:1;		// 如果设置，设备将永久在线。
	bool			offline:1;				// 在成功调用总线类型的 .offline() 后设置。
	bool			of_node_reused:1;		// 设置设备树节点是否与祖先设备共享。
    bool state_synced:1;				// 高版本新增，5.10无。通过调用驱动程序/总线的sync_state()回调函数，此设备的硬件状态已同步，以匹配该设备的软件状态。
    bool can_match:1;					// 高版本新增，5.10无。该设备已至少与一个驱动程序匹配过一次，或者它位于一条总线（如AMBA）中，在其他设备探测成功之前，该总线无法检查匹配的驱动程序。
#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \
    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \
    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)
	bool			dma_coherent:1;			// 该特定设备是DMA一致性的，即使系统架构支持非一致性设备。
#endif
#ifdef CONFIG_DMA_OPS_BYPASS;
    bool dma_ops_bypass : 1;  	/* 高版本新增，5.10无。如果设置为true，则对于流式DMA操作（->map_* / ->unmap_* / ->sync_*）将绕过dma_ops，并且（如果一致性掩码足够大）还可选择性地用于DMA分配。此标志由dma ops实例从->dma_supported进行管理。 */
#endif;
#ifdef CONFIG_DMA_NEED_SYNC;
    bool dma_skip_sync:1;		/* 高版本新增，5.10无。对于一致性缓冲区，可以跳过DMA同步操作。 */
#endif;
#ifdef CONFIG_IOMMU_DMA;
    bool dma_iommu:1;			/* 高版本新增，5.10无。设备正在使用用于直接内存访问（DMA）的默认输入输出内存管理单元（IOMMU）实现，并且不依赖于dma_ops结构。 */
#endif;
};
```





### Device 编程接口

#### 注册设备

`发现设备`的`总线驱动程序`使用此函数向内核`注册该设备`：

```c
// include/linux/device.h
// drivers/base/core.c
int device_register(struct device * dev);
```

总线应初始化以下字段：

- parent 父设备
- name 名称
- bus_id 总线ID
- bus 总线

#### 调整设备引用

当设备的引用计数变为0时，它将从核心中移除。可以使用以下方式调整引用计数：

```c
// include/linux/device.h
// drivers/base/core.c
struct device * get_device(struct device * dev);
void put_device(struct device * dev);  // 释放引用
```

如果引用尚未为0（如果它已在被移除的过程中，即为被完成移除时，引用尚未为0），`get_device()` 将返回一个指向传递给它的 `struct device` 的指针。

#### 设备结构上锁

驱动程序可以使用以下方式访问设备结构中的锁：

```c
void lock_device(struct device * dev);
void unlock_device(struct device * dev);
```


### Device Attribute 属性导出

```c
// include/linux/device.h
struct device_attribute {
      struct attribute        attr;
      ssize_t (*show)(struct device *dev, struct device_attribute *attr,
                      char *buf);
      ssize_t (*store)(struct device *dev, struct device_attribute *attr,
                       const char *buf, size_t count);
};
```

设备的属性可以由设备驱动程序通过sysfs导出。

As explained in Everything you never wanted to know about kobjects, ksets, and ktypes, device attributes must be created before the KOBJ_ADD uevent is generated. The only way to realize that is by defining an attribute group.

设备属性必须在生成KOBJ_ADD用户事件之前创建。实现这一点的唯一方法是定义一个属性组。

属性使用名为`DEVICE_ATTR`的宏进行声明：

```c
// include/linux/device.h
#define DEVICE_ATTR(name,mode,show,store)
// Example:: 示例::
static DEVICE_ATTR(type, 0444, type_show, NULL);
static DEVICE_ATTR(power, 0644, power_show, power_store);
```

这声明了上述两个类型为 struct device_attribute 的结构体，分别名为“dev_attr_type”和“dev_attr_power”。这两个属性可以按如下方式组织成一个组（`单组`）：

```c
static struct attribute *dev_attrs[] = {
      &dev_attr_type.attr,
      &dev_attr_power.attr,
      NULL,
};

static struct attribute_group dev_group = {
      .attrs = dev_attrs,
};

static const struct attribute_group *dev_groups[] = {
      &dev_group,
      NULL,
};
```

对于`单组`的常见情况，有一个辅助宏可用，因此上述两个结构可以使用以下方式声明：

```c
// include/linux/sysfs.h
ATTRIBUTE_GROUPS(dev);
// 原理如下：
#define __ATTRIBUTE_GROUPS(_name)				\
static const struct attribute_group *_name##_groups[] = {	\
	&_name##_group,						\
	NULL,							\
}

#define ATTRIBUTE_GROUPS(_name)					\
static const struct attribute_group _name##_group = {		\
	.attrs = _name##_attrs,					\
};								\
__ATTRIBUTE_GROUPS(_name)
```

然后，在调用 `device_register()` 之前，通过在 struct device 中设置组指针，可将这组数组与设备关联起来：

```c
dev->groups = dev_groups;
device_register(dev);
```

`device_register()`函数将使用“groups”指针来创建设备属性，而`device_unregister()`函数将使用该指针来删除设备属性。

警告：虽然内核允许在任何时候对设备调用`device_create_file()`和`device_remove_file()`，但用户空间对何时创建属性有严格的预期。当在内核中注册一个新设备时，会生成一个uevent来通知用户空间（如udev）有新设备可用。`如果在设备注册后添加属性，那么用户空间将不会收到通知，也就不会知道新的属性`。

这对于那些需要在驱动探测时为设备发布额外属性的设备驱动程序很重要。如果设备驱动程序只是对传递给它的设备结构简单调用 device_create_file()，那么用户空间将永远不会收到有关新属性的通知。



## Devres Device资源管理与托管

### 简介

Devres的出现，是处于 libata 迁移 iomap 时暴露的资源管理问题 的情况下。每个iomap映射的地址都应在驱动程序分离时保留并取消映射。例如，一个普通的SFF ATA控制器（即老式的PCI IDE）在原生模式下使用5个PCI基址寄存器（BAR），所有这些都应予以维护。

与许多其他设备驱动程序一样，libata 底层驱动程序在 ->remove 和 ->probe 失败路径方面存在足够多的漏洞。嗯，没错，这可能是因为 libata 底层驱动程序开发者比较懒，但底层驱动程序开发者不都这样吗？在花费一整天时间摆弄那些没有文档说明或者文档乱七八糟的损坏硬件之后，如果它最终能正常工作，那就行了。

由于这样或那样的原因，底层驱动程序没有像核心代码那样受到足够的关注或测试，而且驱动程序分离或初始化失败的错误发生得不够频繁，不足以引起注意。初始化失败的情况更糟糕，因为它很少出现，但却需要处理多个入口点。

因此，许多低级驱动程序在驱动分离时最终会泄漏资源，并且在 ->probe() 中有不完善的故障处理路径实现，这会在发生故障时导致资源泄漏甚至引发内核错误。iomap 使这种情况更加复杂。MSI 和 MSIX 也是如此。

通过自动化资源释放和简化驱动代码，devres 从根本上提升了内核驱动的可靠性和可维护性。



### Devres

`devres`本质上是一个`链表`，包含与`struct device`关联的`任意大小的内存区域`。每个devres项都关联一个`释放函数`。devres可以通过多种方式释放。无论如何，所有devres项都会在驱动程序分离时释放。释放时，会调用关联的释放函数，然后释放devres项。

使用devres为设备驱动程序常用的资源创建了托管接口。例如，使用`dma_alloc_coherent()`获取一致性DMA内存。`托管版本`称为`dmam_alloc_coherent()`。它与dma_alloc_coherent()完全相同，只是使用`它分配的DMA内存是受管理的`，并且在`驱动程序分离`时将`自动释放`。实现如下：

```c
// kernel/dma/mapping.c
struct dma_devres {
	size_t          size;
	void            *vaddr;
	dma_addr_t      dma_handle;
	unsigned long	attrs;
};

static void dmam_coherent_release(struct device *dev, void *res)
{
	struct dma_devres *this = res;

	dma_free_coherent(dev, this->size, this->vaddr, this->dma_handle);
}

dmam_alloc_coherent(dev, size, dma_handle, gfp)
{
	struct dma_devres *dr;
	void *vaddr;

	dr = devres_alloc(dmam_coherent_release, sizeof(*dr), gfp);
	...

	/* alloc DMA memory as usual */
	vaddr = dma_alloc_coherent(...);
	...

	/* record size, vaddr, dma_handle in dr */
	dr->vaddr = vaddr;
	...

	devres_add(dev, dr);

	return vaddr;
}
```

如果驱动程序使用`dmam_alloc_coherent()`，无论初始化`中途失败`还是`设备被分离`，都能`保证该区域被释放`。如果大多数资源是通过托管接口获取的，驱动程序的初始化和退出代码可以简单得多。初始化流程基本如下：

```c
my_init_one()
{
	struct mydev *d;

	d = devm_kzalloc(dev, sizeof(*d), GFP_KERNEL);
	if (!d)
			return -ENOMEM;

	d->ring = dmam_alloc_coherent(...);
	if (!d->ring)
			return -ENOMEM;

	if (check something)
			return -EINVAL;
	...

	return register_to_upper_layer(d);  // 伪代码
}
```

退出流程：

```c
my_remove_one()
{
	unregister_from_upper_layer(d);  // 伪代码
	shutdown_my_hardware();  // 伪代码
}
```

如上所示，通过使用devres，底层驱动程序可以大大简化。复杂性从维护较少的底层驱动程序转移到维护更好的高层。此外，由于初始化失败路径与退出流程相同，两者都可以得到更多测试。

注意，在将当前调用或赋值转换为托管的 `devm_*` 版本时，需要您`自行检查`诸如`内存分配`之类的内部操作`是否失败`。托管资源`仅`涉及这些资源的释放（着重强调“仅”），所有其他必要的检查仍由您负责。在某些情况下，这可能意味着要引入在迁移到托管的devm_* 调用之前并非必要的检查。


### Devres Group

设备资源项（devres entries）可以使用设备资源组（devres group）进行分组。当一个组被释放时，所有包含的普通设备资源项以及正确嵌套的组`都会被释放`。一种用途是在出现故障时回滚一系列已获取的资源。例如：

```c
	if (!devres_open_group(dev, NULL, GFP_KERNEL))  // drivers/base/devres.c
		return -ENOMEM;

	acquire A;
	if (failed)
		goto err;

	acquire B;
	if (failed)
		goto err;
	...

	devres_remove_group(dev, NULL);
	return 0;

err:
	devres_release_group(dev, NULL);
	return err_code;
```

由于`资源获取失败`通常意味着`探测失败`，上述这样的结构通常在`中层驱动程序`（例如libata核心层）中很有用，在这些地方，接口函数在失败时不应产生副作用。对于底层驱动程序（`LLD`），在大多数情况下，仅返回错误代码就足够了。

每个组由 `void *id` 标识。（1）它既可以通过 `devres_open_group()` 的 `@id` 参数`显式指定`，也可以像上面的示例那样，（2）通过将 `NULL` 作为 `@id` 传入来`自动创建`。在这两种情况下，devres_open_group() 都会返回组的 ID。返回的 ID 可以传递给其他设备资源管理函数，以选择目标组。`如果将 NULL 传递给这些函数，则会选择最新打开的组`。

例如，可以进行如下操作：

```c
int my_midlayer_create_something()
{
      if (!devres_open_group(dev, my_midlayer_create_something, GFP_KERNEL))  // my_midlayer_create_something 所在函数地址
              return -ENOMEM;

      ...

      devres_close_group(dev, my_midlayer_create_something);
      return 0;
}

void my_midlayer_destroy_something()
{
      devres_release_group(dev, my_midlayer_create_something);
}
```


### Devres 细节

- 不涉及引用计数：devres条目的生命周期从devres分配开始，到其被释放或销毁（移除并释放）时结束，`不涉及引用计数`。

- 原子性：devres核心保证了所有基本devres操作的`原子性`，并`支持单实例devres类型`（`原子查找并在未找到时添加`）。除此之外，对已分配的devres数据的并发访问进行同步是调用者的责任。这通常不是问题，因为总线操作和资源分配已经完成了这项工作。

- 单实例devres类型示例：阅读`lib/devres.c`中的`pcim_iomap_table()`。

- 如果给定了正确的 GFP 掩码，所有 devres 接口函数都可以在无上下文的情况下调用。



### Devres 开销

每个设备资源 bookkeeping 信息与`请求的数据区域`一起分配。当调试选项关闭时，bookkeeping 信息在32位机器上占用16字节，在64位机器上占用24字节（三个指针向上舍入到无符号长整型对齐）。如果使用单链表，它可以减少到两个指针（32位上为8字节，64位上为16字节）。

每个设备资源组占用8个指针。如果使用单链表，可减少到6个。

在32位机器上，经过简单转换后，具有两个端口的ahci控制器的内存空间开销在300到400字节之间（我们当然可以在libata核心层上多花些功夫）。


### Devres 托管接口列表

#### CLOCK
devm_clk_get() devm_clk_get_optional() devm_clk_put() devm_clk_bulk_get() devm_clk_bulk_get_all() devm_clk_bulk_get_optional() devm_get_clk_from_child() devm_clk_hw_register() devm_of_clk_add_hw_provider() devm_clk_hw_register_clkdev()

#### DMA
dmaenginem_async_device_register() dmam_alloc_coherent() dmam_alloc_attrs() dmam_free_coherent() dmam_pool_create() dmam_pool_destroy()

#### DRM
devm_drm_dev_alloc()

#### GPIO
devm_gpiod_get() devm_gpiod_get_array() devm_gpiod_get_array_optional() devm_gpiod_get_index() devm_gpiod_get_index_optional() devm_gpiod_get_optional() devm_gpiod_put() devm_gpiod_unhinge() devm_gpiochip_add_data() devm_gpio_request() devm_gpio_request_one()

#### I2C
devm_i2c_add_adapter() devm_i2c_new_dummy_device()

#### IIO
devm_iio_device_alloc() devm_iio_device_register() devm_iio_dmaengine_buffer_setup() devm_iio_kfifo_buffer_setup() devm_iio_kfifo_buffer_setup_ext() devm_iio_map_array_register() devm_iio_triggered_buffer_setup() devm_iio_triggered_buffer_setup_ext() devm_iio_trigger_alloc() devm_iio_trigger_register() devm_iio_channel_get() devm_iio_channel_get_all() devm_iio_hw_consumer_alloc() devm_fwnode_iio_channel_get_by_name()

#### INPUT
devm_input_allocate_device()

#### IO region
devm_release_mem_region() devm_release_region() devm_release_resource() devm_request_mem_region() devm_request_free_mem_region() devm_request_region() devm_request_resource()

#### IOMAP
devm_ioport_map() 
devm_ioport_unmap() 
devm_ioremap() 
devm_ioremap_uc() 
devm_ioremap_wc() 
devm_ioremap_resource() : checks resource, requests memory region, ioremaps 
devm_ioremap_resource_wc() 
devm_platform_ioremap_resource() : calls devm_ioremap_resource() for platform device 
devm_platform_ioremap_resource_byname() 
devm_platform_get_and_ioremap_resource() 
devm_iounmap()

Note: For the PCI devices the specific pcim_*() functions may be used, see below.

#### IRQ
devm_free_irq() devm_request_any_context_irq() devm_request_irq() devm_request_threaded_irq() devm_irq_alloc_descs() devm_irq_alloc_desc() devm_irq_alloc_desc_at() devm_irq_alloc_desc_from() devm_irq_alloc_descs_from() devm_irq_alloc_generic_chip() devm_irq_setup_generic_chip() devm_irq_domain_create_sim()

#### LED
devm_led_classdev_register() devm_led_classdev_register_ext() devm_led_classdev_unregister() devm_led_trigger_register() devm_of_led_get()

#### MDIO
devm_mdiobus_alloc() devm_mdiobus_alloc_size() devm_mdiobus_register() devm_of_mdiobus_register()

#### MEM
devm_free_pages() devm_get_free_pages() devm_kasprintf() devm_kcalloc() devm_kfree() devm_kmalloc() devm_kmalloc_array() devm_kmemdup() devm_krealloc() devm_krealloc_array() devm_kstrdup() devm_kstrdup_const() devm_kvasprintf() devm_kzalloc()

#### MFD
devm_mfd_add_devices()

#### MUX
devm_mux_chip_alloc() devm_mux_chip_register() devm_mux_control_get() devm_mux_state_get()

#### NET
devm_alloc_etherdev() devm_alloc_etherdev_mqs() devm_register_netdev()

#### PER-CPU MEM
devm_alloc_percpu() devm_free_percpu()

#### PCI
devm_pci_alloc_host_bridge() : managed PCI host bridge allocation 
devm_pci_remap_cfgspace() : ioremap PCI configuration space 
devm_pci_remap_cfg_resource() : ioremap PCI configuration space resource

pcim_enable_device() : after success, the PCI device gets disabled automatically on driver detach 
pcim_iomap() : do iomap() on a single BAR 
pcim_iomap_regions() : do request_region() and iomap() on multiple BARs 
pcim_iomap_table() : array of mapped addresses indexed by BAR 
pcim_iounmap() : do iounmap() on a single BAR 
pcim_pin_device() : keep PCI device enabled after release 
pcim_set_mwi() : enable Memory-Write-Invalidate PCI transaction

#### PHY
devm_usb_get_phy() devm_usb_get_phy_by_node() devm_usb_get_phy_by_phandle()

PINCTRL
devm_pinctrl_get() devm_pinctrl_put() devm_pinctrl_get_select() devm_pinctrl_register() devm_pinctrl_register_and_init() devm_pinctrl_unregister()

#### POWER
devm_reboot_mode_register() devm_reboot_mode_unregister()

#### PWM
devm_pwmchip_alloc() devm_pwmchip_add() devm_pwm_get() devm_fwnode_pwm_get()

#### REGULATOR
devm_regulator_bulk_register_supply_alias() devm_regulator_bulk_get() devm_regulator_bulk_get_const() devm_regulator_bulk_get_enable() devm_regulator_bulk_put() devm_regulator_get() devm_regulator_get_enable() devm_regulator_get_enable_read_voltage() devm_regulator_get_enable_optional() devm_regulator_get_exclusive() devm_regulator_get_optional() devm_regulator_irq_helper() devm_regulator_put() devm_regulator_register() devm_regulator_register_notifier() devm_regulator_register_supply_alias() devm_regulator_unregister_notifier()

#### RESET
devm_reset_control_get() devm_reset_controller_register()

#### RTC
devm_rtc_device_register() devm_rtc_allocate_device() devm_rtc_register_device() devm_rtc_nvmem_register()

#### SERDEV
devm_serdev_device_open()

#### SLAVE DMA ENGINE
devm_acpi_dma_controller_register()

#### SPI
devm_spi_alloc_host() devm_spi_alloc_target() devm_spi_optimize_message() devm_spi_register_controller() devm_spi_register_host() devm_spi_register_target()

#### WATCHDOG
devm_watchdog_register_device()



## Device Driver 结构

### Device Driver 结构体定义

设备驱动程序模型会跟踪系统已知的所有驱动程序。进行这种跟踪的主要原因是使驱动程序核心能够将驱动程序与新设备进行匹配。不过，一旦驱动程序成为系统中的已知对象，就可以实现许多其他功能。设备驱动程序可以导出独立于任何特定设备的信息和配置变量。

```c
// include/linux/device.h
struct device_driver {
	const char		*name;		// 设备驱动程序的名称。
	struct bus_type		*bus;	// 该驱动程序所对应的设备所属的总线。

	struct module		*owner;										// 模块所有者。
	const char		*mod_name;	/* used for built-in modules */		// 用于内置模块。

	bool suppress_bind_attrs;	/* disables bind/unbind via sysfs */	// 禁止通过sysfs进行绑定/解绑操作。
	enum probe_type probe_type;											// 要使用的探测类型（同步或异步）。

	const struct of_device_id	*of_match_table;					// The open firmware table. 开放固件匹配表。
	const struct acpi_device_id	*acpi_match_table;					// The ACPI match table. ACPI匹配表。ACPI，高级配置和电源接口。

	int (*probe) (struct device *dev);			// 用于查询特定设备是否存在，判断此驱动程序是否可与之协同工作，并将驱动程序绑定到特定设备。
	void (*sync_state)(struct device *dev);		// 在所有与该设备关联的状态跟踪使用者（在late_initcall时存在）成功绑定到驱动程序后，调用此函数将设备状态同步到软件状态。如果设备没有使用者，此函数将在late_initcall_sync级别被调用。如果设备的使用者从未绑定到驱动程序，则在它们绑定之前，此函数永远不会被调用。高版本，5.10无。
	int (*remove) (struct device *dev);			// 当设备从系统中移除时调用，用于将设备与该驱动解除绑定。
	void (*shutdown) (struct device *dev);		// 在关机时调用，以使设备停止运行。
	int (*suspend) (struct device *dev, pm_message_t state);	// 调用此函数将设备置于睡眠模式。通常是为了降低功耗。
	int (*resume) (struct device *dev);			// 用于将设备从睡眠模式唤醒。
	const struct attribute_group **groups;		// 由驱动程序核心自动创建的默认属性。
	const struct attribute_group **dev_groups;	// 设备实例绑定到驱动程序后附加的其他属性。

	const struct dev_pm_ops *pm;				// 匹配此驱动程序的设备的电源管理操作。
	void (*coredump) (struct device *dev);		// 当写入sysfs条目时调用。预计设备驱动程序将调用 dev_coredump API，从而产生一个 uevent。

	struct driver_private *p;					// 驱动核心的私有数据，除了驱动核心之外，任何人都不能触碰。
};


extern int __must_check driver_register(struct device_driver *drv);
extern void driver_unregister(struct device_driver *drv);

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *driver, char *buf);
	ssize_t (*store)(struct device_driver *driver, const char *buf,
			 size_t count);
};
```


### Device Driver 分配与初始化

分配：设备驱动程序是`静态分配`的结构体。尽管一个系统中可能有`多个设备`由`某个驱动程序支持`，但 `struct device_driver` 代表的是`整个驱动程序`（而`非特定的设备实例`）。

初始化：驱动程序至少必须`初始化名称(name)`和`总线(bus)`字段。它还应初始化`设备类(devclass)`字段（当它可用时，旧版本内核！），以便在内部获得正确的链接。它还应尽可能多地初始化`回调函数`，尽管每个回调函数都是可选的。



### 声明一个 Device Driver

如上所述，struct device_driver 对象是`静态分配`的。以下是 eepro100 驱动程序的一个示例声明。此声明仅为假设；它依赖于`将驱动程序完全转换为新模型`：

```c
static struct device_driver eepro100_driver = {
       .name          = "eepro100",
       .bus           = &pci_bus_type,

       .probe         = eepro100_probe,
       .remove                = eepro100_remove,
       .suspend               = eepro100_suspend,
       .resume                = eepro100_resume,
};
```

`大多数驱动程序无法完全转换为新模型`，因为它们所属的总线具有`特定于总线`的结构和特定于总线的字段，这些`无法进行通用化处理`。

这种情况最常见的例子是`设备ID结构`。驱动程序通常会定义它所支持的`设备ID数组`。`这些结构的格式以及比较设备ID的语义完全特定于总线`。将它们定义为特定于总线的实体将牺牲类型安全性，因此我们`保留特定于总线的结构`。

特定总线驱动程序的定义中应包含通用的 struct device_driver。如下所示：

```c
struct pci_driver {
       const struct pci_device_id *id_table;
       struct device_driver     driver;
};
```

包含特定于总线的字段的定义可能如下（再次使用eepro100驱动程序）：

```c
static struct pci_driver eepro100_driver = {
       .id_table       = eepro100_pci_tbl,
       .driver               = {
              .name           = "eepro100",
              .bus            = &pci_bus_type,
              .probe          = eepro100_probe,
              .remove         = eepro100_remove,
              .suspend        = eepro100_suspend,
              .resume         = eepro100_resume,
       },
};
```

有些人可能会觉得嵌入式结构体初始化的语法很别扭，甚至有点难看。到目前为止，这是找到的实现目标的最佳方式。



### 注册一个 Device Driver

```c
// include/linux/device.h
// drivers/base/driver.c
int driver_register(struct device_driver *drv);
```

驱动程序在启动时注册该结构体。

对于`没有特定总线`字段（即没有特定总线驱动程序结构体）的驱动程序，它们将使用`driver_register`并传入指向其 `struct device_driver` 对象的`指针`。

然而，大多数驱动程序将具有特定于总线的结构，并且需要使用诸如`pci_driver_register`之类的函数`向总线注册`。

驱动程序开发人员应尽早注册其驱动程序结构，这一点很重要。向内核注册会初始化 struct device_driver 对象中的几个字段，包括引用`计数`和`锁`。这些字段在任何时候都被认为是有效的，并且可能会被`设备模型内核`或`总线驱动程序`使用。



### 通用 Driver 过渡到 Bus Driver

通过定义`包装函数`，可以更轻松地过渡到`新模型`。驱动程序可以完全`忽略通用结构`，让总线包装器填充字段。对于回调函数，总线可以定义`通用回调函数`，将调用转发给驱动程序`特定于总线的回调函数`。

这个解决方案只是`临时的`。为了在驱动程序中获取类信息，无论如何都必须对驱动程序进行修改。由于将驱动程序转换为新模型应该会降低一些基础设施的复杂性并减小代码规模，因此建议在添加类信息时进行转换。



### 访问 Device Driver

一旦对象被注册，它就可以访问对象的公共字段，比如锁和设备列表：

```c
int driver_for_each_dev(struct device_driver *drv, void *data,
                        int (*callback)(struct device *dev, void *data));

// include/linux/device.h
// drivers/base/driver.c
int driver_for_each_device(struct device_driver *drv, struct device *start,
			   void *data, int (*fn)(struct device *, void *))
```

`devices`字段是`所有`已绑定到驱动程序的`设备`的列表。LDM (Linux Device Model) 核心提供了一个辅助函数，用于对驱动程序控制的所有设备进行操作。此辅助函数在每次访问节点时`锁定驱动程序`，并在访问每个设备时对其进行`适当的引用计数`。



### Device Drvier 与 sysfs

当注册一个驱动程序时，会在其`总线目录`下创建一个`sysfs目录`。在这个目录中，驱动程序可以`向用户空间导出一个接口`，以便从全局角度控制驱动程序的操作；例如，切换驱动程序中的调试输出。

该目录未来的一项功能将是一个“devices”目录。此目录将包含指向它所支持的设备目录的符号链接。



### Device Driver 相关回调函数

#### probe()

```c
int (*probe)(struct device *dev);
```

`probe()` 入口在`任务上下文`中`被调用`，此时`总线的读写信号量已锁定`，且`驱动程序已部分绑定到设备`。在 probe() 及其他例程中，驱动程序通常使用 `container_of()` 将 `dev` `转换`为`特定于总线的类型`。该类型通常`提供设备资源数据`，例如 `pci_dev.resource[]` 或 `platform_device.resources`，这些数据与 `dev->platform_data` 一起`用于初始化驱动程序`。

此回调包含特定于驱动程序的逻辑，用于`将驱动程序绑定到给定设备`。这包括`验证设备是否存在`、`其版本是否为驱动程序可处理的版本`、`是否可以分配和初始化驱动程序数据结构`，以及`是否可以初始化任何硬件`。驱动程序通常使用 `dev_set_drvdata()` 存储 `指向其状态的指针`。当驱动程序成功将自身绑定到该设备时，probe() 将返回`零`，驱动程序模型代码将完成其将驱动程序绑定到该设备的部分工作。

驱动程序的probe()函数可能返回一个`负的errno值`，以表明驱动程序未绑定到该设备，在这种情况下，它`应释放已分配的所有资源`。

如果驱动程序`依赖的资源尚不可用`（例如，由尚未初始化的驱动程序提供的资源），probe() 函数可以选择返回 `-EPROBE_DEFER`。驱动程序核心会将设备`放入延迟探测列表`，并在`稍后尝试`再次调用该函数。如果驱动程序必须延迟，`应尽早`返回 `-EPROBE_DEFER`，以减少在设置工作上花费的时间，因为这些工作稍后需要回滚并重新执行。

Warning!!! 如果probe()`已经创建设备子项`，即便这些设备子项在清理过程中`又被移除`，也`一定不能`返回`-EPROBE_DEFER`。如果在注册设备子项后返回`-EPROBE_DEFER`，可能会导致`对同一驱动程序的probe()`调用`陷入无限循环`。


#### sync_state()

```c
void (*sync_state)(struct device *dev);
```

`sync_state` 对`一个设备仅调用一次`。当该设备的`所有消费类设备`都`成功探测`到时，就会`调用此函数`。设备的`消费类设备列表`是`通过查看将该设备连接到其消费类设备的设备链接来获取的`。

首次调用`sync_state()`是在`late_initcall_sync()`期间进行的，目的是`为固件和驱动程序留出时间，以便将设备相互连接`。在首次尝试调用`sync_state()`时，如果此时设备的所有使用者都已成功探测，就会立即调用`sync_state()`。如果在首次尝试时设备`没有使用者，这也会被视为“设备的所有使用者都已探测”`，并立即调用`sync_state()`。

如果在首次尝试为设备调用sync_state()时，仍有使用者未能成功探测，则sync_state()调用将`被推迟`，并且仅在该设备的一个或多个使用者成功探测后，才会在未来重新尝试调用。如果在重新尝试期间，驱动程序核心发现该设备仍有一个或多个使用者尚未探测，则sync_state()调用将再次被推迟。

sync_state()的一个典型用例是`让内核平稳地从引导加载程序接管设备管理`。例如，如果引导加载程序使设备处于开启状态并处于特定的硬件配置，设备驱动程序`可能需要将设备保持在引导配置`，直到设备的所有使用者都完成探测。一旦设备的`所有使用者都完成探测`，设备驱动程序就可以`同步设备的硬件状态`，以匹配所有使用者请求的聚合软件状态。这就是sync_state()名称的由来。

虽然可以从sync_state()中受益的资源的明显例子包括`regulator`调节器等资源，但sync_state()对`IOMMU`等复杂资源也很有用。例如，具有多个使用者（其地址由IOMMU重新映射的设备）的IOMMU可能需要将其映射固定在启动配置（或在`启动配置基础上添加`），直到其所有使用者都已探测完毕。

虽然`sync_state()`的典型用例是让内核从引导加载程序干净利落地接管设备管理，但`sync_state()`的使用并不局限于此。只要在设备的所有使用者探测完成后采取行动是合理的，就可以使用它。sync_state() 是内核控制的单向回调机制，驱动程序不能随时调用，仅能通过实现该函数定义具体逻辑，由内核在满足条件时自动触发。



#### remove()

```c
int (*remove)(struct device *dev);
```

调用remove函数是为了`将驱动程序与设备解除绑定`。当设备已从系统中物理移除、或驱动程序模块正在卸载、或系统重启过程中或其他情况下，都可能调用该函数。

`设备是否存在由驱动程序决定`。驱动程序`应释放为该设备专门分配的所有资源`，即设备的`driver_data`字段中的任何内容。

如果设备仍然存在，它应使设备`进入静止状态`，并将其置于支持的`低功耗状态`。


#### suspend()

```c
int (*suspend)(struct device *dev, pm_message_t state);
```

调用suspend将设备置于低功耗状态。



#### resume()

```c
int (*resume)(struct device *dev);
```

恢复用于将设备从低功耗状态恢复。



### Drvier Attribute 属性导出

设备驱动程序可以通过其sysfs目录导出属性。驱动程序可以使用`DRIVER_ATTR_RW`和`DRIVER_ATTR_RO`宏声明属性，其工作方式与`DEVICE_ATTR_RW`和`DEVICE_ATTR_RO`宏完全相同。

示例：
```c
DRIVER_ATTR_RW(debug);
```

这等效于声明：
```c
struct driver_attribute driver_attr_debug;
```

然后，可以使用以下方式`在驱动程序目录中添加和删除该属性`：

```c
int driver_create_file(struct device_driver *, const struct driver_attribute *);
void driver_remove_file(struct device_driver *, const struct driver_attribute *);
```



## Linux 内核设备模型

### 概述

Linux内核驱动模型是`对之前在内核中使用的所有不同驱动模型的统一`。它旨在`通过将一组数据和操作整合到全局可访问的数据结构中`，来`增强针对桥接器和设备的特定总线驱动程序`。

`传统的驱动程序模型`为它们`所控制的设备`实现了`某种树状结构`（有时只是一个列表）。不同总线类型之间没有任何一致性。

`当前的驱动模型`提供了一个`通用、统一的数据模型`，用于`描述总线以及可能出现在该总线下的设备`。统一的总线模型包含一组`所有总线`都具备的`通用属性`，以及一组`通用回调函数`，例如在总线探测期间的`设备发现`、`总线关闭`、`总线电源管理`等。

通用设备和桥接接口体现了现代计算机的目标：即实现设备无缝`即插即用`、`电源管理`和`热插拔`的能力。特别是英特尔和微软制定的模型（即ACPI）确保了x86兼容系统上几乎任何总线上的几乎每一个设备都能在这种模式下工作。当然，并非每条总线都能支持所有这些操作，尽管大多数总线支持其中的大部分操作。



### 下游驱动对设备的访问

常见的数据字段已从各个总线层移出，合并到一个`通用数据结构`中。这些字段仍必`须由总线层访问`，有时还需由`特定设备的驱动程序访问`。

鼓励其他总线层`效仿PCI层`的做法。`pci_dev` 结构体现在如下所示：

```c
struct pci_dev {
      ...

      struct device dev;     /* Generic device interface */
      ...
};
```

首先要注意，`struct pci_dev` 中的 `struct device` 结构体 `dev` 是静态分配的。这意味着在`设备`发现时`仅进行一次分配`。

还要注意，`struct device dev` 不一定在 `pci_dev` 结构体的开头定义。这样做是为了让人们在`总线驱动程序`和`全局驱动程序`之间切换时思考自己在做什么，并防止在两者之间进行无意义且错误的类型转换。

`PCI总线层`可以`自由访问` struct device 的各个字段。它了解 struct pci_dev 的结构，也应该了解 struct device 的结构。已转换为当前驱动模型的各个PCI设备`驱动程序`通常`不会也不应该`触及 `struct device` 的字段，除非有令人信服的理由这样做。

上述抽象避免了过渡阶段不必要的麻烦。如果不这样做，那么当某个字段被重命名或删除时，每个下游驱动程序都会出现故障。另一方面，如果只有总线层（而非设备层）访问 struct device ，那么只需修改总线层即可。



### 用户接口 sysfs

由于对系统中的`所有设备`都有`完整的层次结构视图`，因此将完整的层次结构视图导出到用户空间就变得相对容易。这通过实现一个名为`sysfs`的`专用虚拟文件系统`来完成。


**挂载 sysfs**

几乎所有主流的Linux发行版都会自动挂载这个文件系统；你可以在`mount`命令的输出中看到类似于以下内容：

```bash
$ mount
...
none on /sys type sysfs (rw,noexec,nosuid,nodev)
...
$
```

`sysfs`的自动挂载通常通过在`/etc/fstab`文件中添加类似如下的条目来实现：

```bash
none          /sys    sysfs    defaults               0 0
```

或者在基于 Debian 的系统上的 `/lib/init/fstab` 文件中有类似内容：

```bash
none            /sys    sysfs    nodev,noexec,nosuid    0 0
```

如果sysfs没有自动挂载，你始终可以使用以下命令`手动挂载`：

```bash
mount -t sysfs sysfs /sys
```

**Device 与 sysfs**

每当将设备插入树中时，都会为其创建一个目录。此目录可能会在发现的每个层级（`全局层级`、`总线层级`或`设备层级`）中进行填充。

`全局层`目前会创建两个`文件`——`name`和`power`。前者仅报告设备名称。后者报告设备当前的电源状态，也将用于设置当前电源状态。

`总线层`在探测总线时，也可能为其找到的设备`创建文件`。例如，`PCI层`目前会为每个PCI设备创建`irq`和`resource`文件。

`特定设备驱动程序`也可以将其目录中的文件导出，以`公开特定设备的数据`或`可调接口`。

> 有关sysfs目录布局的更多信息，可以在该目录中的其他文档以及文件[sysfs - 用于导出内核对象的文件系统](https://www.kernel.org/doc/html/latest/filesystems/sysfs.html)中找到。




## Platform Devices & Drivers 结构

有关平台总线的驱动程序模型接口，请参阅 <linux/platform_device.h>：`platform_device` 和 `platform_driver`。这种`伪总线`用于`连接`基础设施`极少的总线上的设备`，比如许多片上系统处理器上用于`集成外设的总线`，或者一些 “传统的” PC互连；`与PCI或USB等有正式规范的大型总线不同`。


### Platform Devices 平台设备

平台设备通常是指在系统中表现为`独立实体`的设备。这包括`传统的基于端口的设备`、`连接到外设总线的主机桥`，以及大多数`集成到片上系统平台的控制器`。它们的共同特点通常是`可由CPU总线直接寻址`。极少数情况下，平台设备会通过某种其他总线的一段进行连接；`但其寄存器仍可直接寻址`。

平台设备会被赋予一个`名称`（用于驱动绑定）以及一个`资源列表`，如`地址和中断请求（IRQ）`：

```c
// include/linux/platform_device.h
struct platform_device {
	const char	*name;				// * 
	int		id;						// * 
	bool		id_auto;
	struct device	dev;			// * 
	u64		platform_dma_mask;
	u32		num_resources;			// * 
	struct resource	*resource;		// * 

	const struct platform_device_id	*id_entry;
	/*
	 * Driver name to force a match.  Do not set directly, because core
	 * frees it.  Use driver_set_override() to set or clear it.
	 */
	const char *driver_override;

	/* MFD cell pointer */
	struct mfd_cell *mfd_cell;

	/* arch specific additions */
	struct pdev_archdata	archdata;
};
```

通常情况下，特定于平台（通常也是特定于开发板）的设置代码会`注册平台设备`：

```c
// include/linux/platform_device.h
// drivers/base/platform.c
int platform_device_register(struct platform_device *pdev);
void platform_device_unregister(struct platform_device *pdev);

int platform_add_devices(struct platform_device **pdevs, int ndev);
```

一般规则是`只注册实际存在的设备`，但在某些情况下，`可能会注册额外的设备`。例如，内核可能被配置为与外部`网络适配器`配合工作，而并非所有板卡都配备该适配器；同样，也可能配置为与`集成控制器`配合工作，而某些板卡可能并未连接任何外围设备。

在某些情况下，`引导固件会导出描述特定电路板上所安装设备的表格`。如果没有这些表格，系统设置代码通常只能通过`为特定目标电路板构建内核`来设置正确的设备。这种特定于电路板的内核在嵌入式系统和定制系统开发中很常见。

在许多情况下，`与平台设备相关联的内存和IRQ资源不足以让设备的驱动程序正常工作`。板级设置代码通常会使用设备的`platform_data`(`struct device {}`)字段提供额外信息，以保存更多信息。

嵌入式系统通常需要为平台设备`配备一个或多个时钟`，这些时钟在实际需要之前通常处于关闭状态（以节省电量）。系统设置还会将这些时钟与设备关联起来，以便在需要时，通过调用`clk_get(&pdev->dev, clock_name)`获取时钟。



### Platform Drivers 平台驱动

平台驱动程序`遵循标准驱动程序模型`约定，其中发现/枚举在驱动程序外部处理，驱动程序提供`probe()`和`remove()`方法。它们使用`标准约定支持电源管理`和`关机通知`：

```c
struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t state);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
};
```

请注意，一般来说，`probe()` 函数`应验证指定的设备硬件是否真实存在`；有时平台设置代码无法确定。探测过程可以使用`设备资源`，包括`时钟`和`设备平台数据`。

平台驱动程序以常规方式`注册`自身：

```c
int platform_driver_register(struct platform_driver *drv);
```

或者，在`已知`设备`不可热插拔`的常见情况下，probe() 例程可以放在初始化段中，以减少驱动程序运行时的内存占用：

```c
int platform_driver_probe(struct platform_driver *drv,
                  int (*probe)(struct platform_device *))
```

内核模块可以由`多个平台驱动程序`组成。平台核心提供了用于注册和注销`驱动程序数组`的辅助函数：

```c
int __platform_register_drivers(struct platform_driver * const *drivers,
                              unsigned int count, struct module *owner);
void platform_unregister_drivers(struct platform_driver * const *drivers,
                                 unsigned int count);
```

如果`其中一个`驱动程序`注册失败`，那么截至该点已注册的所有驱动程序将按`相反顺序注销`。请注意，有一个便捷宏会将`THIS_MODULE`作为所有者参数传递：

```c
#define platform_register_drivers(drivers, count) \
	__platform_register_drivers(drivers, count, THIS_MODULE)
```


### 传统驱动：设备探测

一些驱动程序并未完全转换为驱动模型，因为它们承担了非驱动角色：驱动程序注册其平台设备，而不是将此任务留给系统基础架构。这类驱动程序`无法进行热插拔或冷插拔`，因为这些机制`要求设备创建由不同于驱动程序的系统组件`来完成。

这么做的唯一“正当”理由是为了`处理旧的系统设计`，这些系统，比如最初的IBM个人电脑，依赖容易出错的“探测硬件”模式来进行硬件配置。较新的系统大多已摒弃了这种模式，转而采用`总线级别的动态配置支持（如PCI、USB）`，或者由引`导固件提供的设备表`（例如x86架构上的 PNPACPI ）。关于设备`可能所在的位置存在太多相互冲突`的选项，即便操作系统经过推敲的猜测也常常出错，从而引发问题。

`不推荐使用这种驱动程序风格`。如果您正在更新此类驱动程序，请尝试将`设备枚举`移至更合适的位置，即`驱动程序外部`。这通常是清理工作，因为此类驱动程序通常已经具备 “常规” 模式，例如使用由`即插即用（PNP）`或`平台设备设置创建的设备节点的模式`。

尽管如此，还是有一些应用程序编程接口（API）支持此类旧版驱动程序。除非是使用此类不支持热插拔的驱动程序，否则应`避免使用`这些调用：

```c
// include/linux/platform_device.h
// drivers/base/platform.c
struct platform_device *platform_device_alloc(const char *name, int id)
```

你可以使用 `platform_device_alloc()` 来`动态分配设备`，然后`使用资源对其进行初始化`，并通过 `platform_device_register()` 进行注册。通常`更好的解决方案`是：

```c
// include/linux/platform_device.h
struct platform_device *platform_device_register_simple(
                const char *name, int id,
                struct resource *res, unsigned int nres);
```

你可以使用 `platform_device_register_simple()` 一步完成设备的分配与注册。



### 设备命名与驱动绑定

`platform_device.dev.bus_id` 是`设备的规范名称`。它由两个部分组成：

- `platform_device.name`: 它也用于驱动程序匹配。
- `platform_device.id`: 设备实例编号，否则为“-1”，表示只有一个设备。



这些是拼接在一起的，组成规则如下，name/id：

- `serial/0` 表示 bus_id 为 `serial.0`, 使用名为 `serial` 的`平台驱动程序`
- `serial/3` 表示 bus_id 为 `serial.3`, 使用名为 `serial` 的`平台驱动程序`
- `my_rtc/-1` 表示 bus_id 为 `my_rtc`（无实例 ID），使用名为 `my_rtc` 的`平台驱动程序`


`驱动绑定`由`驱动核心自动执行`，在找到设备与驱动之间的`匹配项`后调用驱动的`probe()`函数。如果`probe()`函数执行成功，驱动和设备将按常规方式绑定。有三种不同的方式来找到这样的`匹配项`：

- 每当注册一个设备时，`会检查该总线的驱动程序是否匹配`。平台设备应在系统启动的`早期`就进行注册。
- 当使用 `platform_driver_register()` 注册驱动程序时，`会检查该总线上所有未绑定的设备是否匹配`。驱动程序通常在启动过程的`稍后阶段`，或通过加载模块进行注册。
- 使用 `platform_driver_probe()` 注册驱动程序的工作方式与使用 `platform_driver_register()` 类似，不同之处在于，如果另一个设备注册，该驱动程序稍后不会被探测。（这是可以的，因为此接口`仅`用于`不可热插拔`的设备，即不能插入新的设备。）



### 早期平台设备和驱动

早期平台接口在`系统启动初期`就`将平台数据提供给平台设备驱动程序`。这段代码基于`early_param()`命令行解析构建，并且可以在启动初期就执行。

示例：分6步实现`earlyprintk`类早期串行控制台

1. **注册早期平台设备数据**: 该架构代码使用函数`early_platform_add_devices()`注册平台设备数据。对于早期串行控制台，这应该是串口的硬件配置。在此处注册的设备稍后将与早期平台驱动程序进行匹配。
2. **解析内核命令行**: 架构代码调用parse_early_param()来解析内核命令行。这将执行所有匹配的early_param()回调函数。用户指定的早期平台设备将在此处注册。对于早期串口控制台的情况，用户可以在内核命令行上指定端口为“earlyprintk=serial.0”，其中“earlyprintk”是类字符串，“serial”是平台驱动程序的名称，0是平台设备ID。如果ID为-1，则可以省略点号和ID。
3. **安装属于某个类别的早期平台驱动程序**: 架构代码可以选择使用函数early_platform_driver_register_all()强制注册属于某个类别的所有早期平台驱动程序。第2步中用户指定的设备优先于这些驱动程序。由于除非用户在内核命令行中指定了端口，否则早期串口驱动程序代码应被禁用，因此串口驱动程序示例省略了此步骤。
4. **早期平台驱动程序注册**: 利用early_platform_init()的内置平台驱动程序会在步骤2或步骤3中自动注册。串行驱动程序示例应使用early_platform_init("earlyprintk", &platform_driver)。
5. **对属于特定类别的早期平台驱动程序的探测**: 架构代码调用early_platform_driver_probe()，将与特定类相关联的已注册早期平台设备与已注册的早期平台驱动程序进行匹配。匹配的设备将被探测（probed()）。这一步骤可以在早期启动的任何时刻执行。对于串口情况，尽早执行可能比较好。
6. **在早期平台驱动的probe()函数内部**: 驱动程序代码在早期启动期间需要特别小心，尤其是在内存分配和中断注册方面。probe() 函数中的代码可以使用is_early_platform_device() 来检查它是在早期平台设备阶段还是在常规平台设备阶段被调用。早期串口驱动程序会在此处执行register_console() 操作。


> 如需更多信息，请参阅 <linux/platform_device.h> 。



## 移植驱动到新驱动模型

将设备驱动程序移植到新模型的大部分工作都发生在`总线驱动程序层`。这是有意为之，目的是将对内核驱动程序的负面影响降至最低，并使总线驱动程序能够逐步过渡。

简而言之，`驱动程序模型`由`一组对象组成`，这些对象可以嵌入到更大的、`特定于总线的对象`中。这些`通用对象中的字段`可以替换`特定于总线的对象中的字段`。

`通用对象`必须在驱动模型核心中`注册`。通过这样做，它们将通过sysfs文件系统导出。可以通过以下方式挂载sysfs：

```bash
# mount -t sysfs sysfs /sys
```

流程如下：

### 步骤1：注册总线驱动程序

1. 为 `总线驱动` 定义一个总线类型 `struct bus_type`:

```c
struct bus_type pci_bus_type = {
      .name           = "pci",
};
```

2. 注册总线类型

这应该在总线类型的初始化函数中完成，该函数通常是 module_init() 或等效函数：

```c
  static int __init pci_driver_init(void)
{
        return bus_register(&pci_bus_type);
}

subsys_initcall(pci_driver_init);
```

可以通过以下方式注销总线类型（前提是总线驱动程序可以编译为一个模块）：

```c
bus_unregister(&pci_bus_type);
```

3. 导出总线类型供其他模块使用

其他代码可能希望引用总线类型，因此在共享头文件中声明它并导出该符号。

从 include/linux/pci.h 中：

```c
extern struct bus_type pci_bus_type;
```

上述代码所在的文件：

```c
EXPORT_SYMBOL(pci_bus_type);
```

4. 这将导致该总线在 /sys/bus/pci/ 中显示，并带有两个子目录：“devices”（设备）和“drivers”（驱动程序）：

```c
# tree -d /sys/bus/pci/
/sys/bus/pci/
|-- devices
`-- drivers
```


### 步骤2：注册设备

`struct device` 代表单个设备。它主要包含描述该`设备与其他实体关系`的`元数据`。

1. 将`struct device`嵌入特定于总线的设备类型中：

```c
struct pci_dev {
       ...
       struct  device  dev;            /* Generic device interface */
       ...
};
```

建议通用设备`不要`作为结构体中的`第一个元素`，以防止程序员在对象类型之间进行盲目转换。相反，应该`创建宏或内联函数`，用于从通用对象类型进行`转换`：

```c
// dev 为 pci_dev 中的成员名
#define to_pci_dev(n) container_of(n, struct pci_dev, dev)

// or

static inline struct pci_dev * to_pci_dev(struct kobject * kobj)
{
    return container_of(n, struct pci_dev, dev);
}
```

这使得编译器能够验证所执行操作的类型安全性（这是件好事）。


2. 注册时初始化设备

当设备被发现或在总线类型中注册时，总线驱动程序应初始化通用设备。需要初始化的最重要的内容是 bus_id, parent 和 bus 字段:

  - bus_id 是一个ASCII字符串，包含设备在总线上的地址。此字符串的格式`因总线而异`。这对于在sysfs中表示设备是必要的。
  - parent 是设备的物理父设备。总线驱动程序正确设置此字段非常重要。

驱动程序模型维护`一个设备的有序列表`，用于`电源管理`。此列表必须按顺序排列，以确保`设备在其物理父设备之前关闭`，反之亦然。此列表的顺序由已注册设备的`父设备决定`。

此外，`设备的sysfs目录位置取决于设备的父级`。sysfs导出的目录结构反映了设备层次结构。准确设置父级可确保sysfs准确表示该层次结构。

该`设备的总线`(bus)字段是一个指针，指向`该设备所属的总线类型`。这应该设置为之前声明并初始化的`bus_type`。

或者，总线驱动程序可以设置设备`名称`和`释放`字段:

  - 名称字段是一个ASCII字符串，用于描述设备，例如 “ATI Technologies Inc Radeon QD” “ATI Technologies Inc Radeon QD”。
  - 释放字段是一个回调函数，当设备已被移除且对其的所有引用均已释放时，驱动程序模型核心会调用该回调函数。稍后对此进行详细介绍。


3. 注册设备

一旦`通用设备初始化`完成，可通过以下操作在驱动模型核心中注册该设备：

```c
device_register(&dev->dev);
```

之后，可以通过以下操作将其注销：

```c
device_unregister(&dev->dev);
```

这应该发生在`支持热插拔设备`的`总线`上。如果总线驱动程序注销一个设备，它`不应该立即释放该设备`。相反，它应该`等待驱动程序模型核心调用设备的释放方法`，然后`再释放特定于总线的对象`。（`可能存在其他代码当前正在引用该设备结构`，在这种情况下释放设备是不合适的）。

设备注册时，会在sysfs中创建一个目录。sysfs中的PCI树如下所示：

```
/sys/devices/pci0/
|-- 00:00.0
|-- 00:01.0
|   `-- 01:00.0
|-- 00:02.0
|   `-- 02:1f.0
|       `-- 03:00.0
|-- 00:1e.0
|   `-- 04:04.0
|-- 00:1f.0
|-- 00:1f.1
|   |-- ide0
|   |   |-- 0.0
|   |   `-- 0.1
|   `-- ide1
|       `-- 1.0
|-- 00:1f.2
|-- 00:1f.3
`-- 00:1f.5
```

此外，在总线的“devices”目录中会创建符号链接，这些链接指向物理层级结构中设备的目录：

```c
/sys/bus/pci/devices/
|-- 00:00.0 -> ../../../devices/pci0/00:00.0
|-- 00:01.0 -> ../../../devices/pci0/00:01.0
|-- 00:02.0 -> ../../../devices/pci0/00:02.0
|-- 00:1e.0 -> ../../../devices/pci0/00:1e.0
|-- 00:1f.0 -> ../../../devices/pci0/00:1f.0
|-- 00:1f.1 -> ../../../devices/pci0/00:1f.1
|-- 00:1f.2 -> ../../../devices/pci0/00:1f.2
|-- 00:1f.3 -> ../../../devices/pci0/00:1f.3
|-- 00:1f.5 -> ../../../devices/pci0/00:1f.5
|-- 01:00.0 -> ../../../devices/pci0/00:01.0/01:00.0
|-- 02:1f.0 -> ../../../devices/pci0/00:02.0/02:1f.0
|-- 03:00.0 -> ../../../devices/pci0/00:02.0/02:1f.0/03:00.0
`-- 04:04.0 -> ../../../devices/pci0/00:1e.0/04:04.0
```


### 步骤3：注册驱动程序

`struct device_driver`是一个简单的驱动程序结构，包含驱动程序模型核心可能调用的一组操作。

1. 在特定总线驱动程序中嵌入一个`struct device_driver`。就像处理设备一样，执行类似以下操作：

```c
struct pci_driver {
       ...
       struct device_driver    driver;
};
```


2. 初始化通用驱动程序结构。

当驱动程序向总线注册时（例如执行`pci_register_driver()`），初始化驱动程序的必要字段：`名称`和`总线`字段。


3. 注册驱动程序。

通用驱动程序初始化完成后，调用：

```c
driver_register(&drv->driver);
```

向`内核`注册驱动程序。

当驱动程序从总线上注销时，通过执行以下操作将其从内核中注销：

```c
driver_unregister(&drv->driver);
```

请注意，这将`阻塞`，`直到所有对驱动程序的引用都消失`。通常情况下，不会有任何引用。


4. sysfs表示形式

驱动程序通过sysfs在其总线的“driver”目录中导出。例如：

```
/sys/bus/pci/drivers/
|-- 3c59x
|-- Ensoniq AudioPCI
|-- agpgart-amdk7
|-- e100
`-- serial
```



### 步骤4：为驱动程序定义通用方法

`struct device_driver` 定义了驱动模型核心调用的一组操作。其中大多数操作可能与总线已经为驱动程序定义的操作类似，但采用不同的参数。

强制总线上的每个驱动程序同时将其驱动程序转换为通用格式既困难又繁琐。相反，`总线驱动程序`应定义`通用方法`的`单个实例`，这些实例`将调用转发到特定于总线的驱动程序`。例如：

```c
static int pci_device_remove(struct device * dev)
{
        struct pci_dev * pci_dev = to_pci_dev(dev);
        struct pci_driver * drv = pci_dev->driver;

        if (drv) {
                if (drv->remove)
                        drv->remove(pci_dev);
                pci_dev->driver = NULL;
        }
        return 0;
}
```

通用驱动程序在注册之前，应该使用这些方法进行初始化：

```c
/* initialize common driver fields */
drv->driver.name = drv->name;
drv->driver.bus = &pci_bus_type;
drv->driver.probe = pci_device_probe;
drv->driver.resume = pci_device_resume;
drv->driver.suspend = pci_device_suspend;
drv->driver.remove = pci_device_remove;

/* register with core */
driver_register(&drv->driver);
```

理想情况下，`总线`应该`仅在字段尚未设置时才对其进行初始化`。这使得驱动程序能够实现自己的通用方法。



### 步骤5：支持通用驱动程序绑定

该模型假定`设备`或`驱动程序`可`随时在总线上动态注册`。注册发生时，`设备必须绑定到驱动程序`，或者`驱动程序必须绑定到它支持的所有设备`。

`驱动程序`通常包含一个它`所支持的设备ID列表`。`总线驱动程序`会`将这些ID与向它注册的设备的ID进行比较`。设备ID的格式以及比较它们的语义都是`特定于总线`的，所以`通用模型不会尝试对其进行泛化`。

相反，总线可以在 `struct bus_type` 中提供一个进行`比较`的方法：

```c
int (*match)(struct device * dev, struct device_driver * drv);
```

如果驱动程序支持该设备，`match` 应返回正值，否则返回零。如果无法确定给定驱动程序是否支持该设备，它也可能返回错误代码（例如 `-EPROBE_DEFER`）。

当一个`设备被注册时`，会遍历总线上的驱动程序列表。对`每个驱动程序`调用`bus->match()`函数，`直到找到匹配项`为止。

当`注册一个驱动程序时`，会遍历总线上的设备列表。对于`每个尚未被其他驱动程序占用的设备`，都会调用`bus->match()`。

当一个设备成功绑定到驱动程序时，`device->driver` 会被设置，该设备会被添加到每个驱动程序的设备列表中，并且会在驱动程序的 sysfs 目录中创建一个符号链接，该链接指向设备的`物理目录`：

```
/sys/bus/pci/drivers/
|-- 3c59x
|   `-- 00:0b.0 -> ../../../../devices/pci0/00:0b.0
|-- Ensoniq AudioPCI
|-- agpgart-amdk7
|   `-- 00:00.0 -> ../../../../devices/pci0/00:00.0
|-- e100
|   `-- 00:0c.0 -> ../../../../devices/pci0/00:0c.0
`-- serial
```

这种`驱动程序绑定`应该取代`总线`当前使用的现有驱动程序绑定机制。



### 步骤6：提供热插拔回调函数

每当`设备`向驱动程序模型核心`注册`时，用户空间程序`/sbin/hotplug`就会`被调用`，以通知用户空间。用户可以定义在设备插入或移除时要执行的操作。

驱动模型核心通过`环境变量`向用户空间`传递`几个`参数`，包括:
- `ACTION`: set to `add` or `remove`
- `DEVPATH`: 设置为`设备`在`sysfs`中的`物理路径`

`总线驱动程序`也可以提供`额外的参数`供用户空间使用。要做到这一点，总线必须在`struct bus_type`中实现`hotplug`方法：

```c
int (*hotplug) (struct device *dev, char **envp,
                int num_envp, char *buffer, int buffer_size);
```

这会在执行 `/sbin/hotplug` 之前立即调用。



### 步骤7：清理总线驱动程序

通用`总线`、`设备`和`驱动程序`结构提供了几个字段，这些字段可以`替代总线驱动程序`中私有定义的字段。

1. Device list

`struct bus_type` 包含向该总线类型注册的`所有设备的列表`。这包括该总线类型`所有实例上的所有设备`。`总线使用的内部列表可能会被移除`，转而使用此列表。

核心提供了一个迭代器来访问这些设备：

```c
int bus_for_each_dev(struct bus_type * bus, struct device * start,
                     void * data, int (*fn)(struct device *, void *));
```


2. Driver list

`struct bus_type` 还包含向其注册的`所有驱动程序的列表`。`总线驱动程序维护的内部驱动程序列表可能会被移除`，转而使用通用列表。

可以像遍历设备那样遍历驱动程序：

```c
int bus_for_each_drv(struct bus_type * bus, struct device_driver * start,
                     void * data, int (*fn)(struct device_driver *, void *));
```

有关更多信息，请参阅`drivers/base/bus.c`。


3. rwsem

`struct bus_type` 包含一个`读写信号量`，用于`保护对设备和驱动程序列表`的所有核心访问。总线驱动程序可在内部使用此信号量，并且在`访问总线维护的设备或驱动程序列表时应使用它`。




4. Device and driver fields

在`struct device`和`struct device_driver`中的一些字段，与这些对象`在特定总线`表示中的`字段重复`。你可以放心地`删除特定总线的字段`，`优先使用通用字段`。不过要注意，这可能意味着要修正所有引用特定总线字段的驱动程序（不过这些修改应该都只需一行代码）。


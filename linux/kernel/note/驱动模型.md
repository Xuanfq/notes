# 驱动模型

Refer:

- [Driver implementer’s API guide — The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/driver-api/index.html)
- [Driver Model — The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/driver-api/driver-model/index.html)


## Device Driver 绑定

驱动程序绑定是将设备与能够控制它的设备驱动程序相关联的过程。通常由`总线驱动程序来处理这个问题`，因为一直存在特定于总线的结构来表示设备和驱动程序。有了通用的设备和设备驱动程序结构，大部分绑定都可以使用通用代码来完成。

### 1. Bus

`Bus` 包含:
- `Device`: 由 `device_register` 插入 Bus 列表
- `Driver`: 由 `driver_register` 插入 Bus 列表

总线类型结构包含系统中该总线类型上所有设备的列表。

当为某个设备调用device_register时，该设备会被插入到此列表的末尾。

总线对象还包含该总线类型所有驱动程序的列表。

当为某个驱动程序调用driver_register时，该驱动程序会被插入到此列表的末尾。这两个事件会触发驱动程序绑定。


### 2. device_register

当`添加新设备`时，会遍历总线的驱动程序列表，以找到一个支持该设备的驱动程序。

为了确定这一点，设备的设备ID必须与驱动程序支持的设备ID之一相匹配。比较ID的格式和语义因总线而异。

与其尝试推导复杂的状态机和匹配算法，不如由总线`驱动程序`提供一个`回调函数`(`.match`)，将设备与驱动程序的ID进行比较。如果找到匹配项，总线返回1；否则返回0。

```
int match(struct device * dev, struct device_driver * drv);
```

如果找到匹配项，设备的驱动程序字段将`设置为该驱动程序`，并且会`调用驱动程序的探测回调函数`(`.probe`)。这使驱动程序有机会验证其`是否真正支持该硬件`，以及该`硬件是否处于工作状态`。


### 3. Device Class

在成功完成`探测`(`.probe`)后，`设备`会向其`所属的类`注册。设备驱动程序只属于一个类，这个类在`驱动程序`的`devclass`字段中设置。调用`devclass_add_device`函数在类中枚举设备，并通过类的`register_dev`回调函数`实际向该类注册设备`。


### 4. Driver

当一个驱动程序附加到一个设备时，该设备会被插入到驱动程序的设备列表中。


### 5. sysfs

在`总线`的“devices”目录中会创建一个`符号链接`，它指向`物理层级结构中设备的目录`。

在`驱动程序`的“devices”目录中会创建一个`符号链接`，它指向`物理层级结构中设备的目录`。

在`类的目录`中会为该设备创建一个目录。在该目录中会创建一个`符号链接`，它指向该设备在`sysfs树中的物理位置`。

可以在设备的`物理目录`中创建一个`符号链接`，该符号链接可以指向其`类目录`，也可以指向`该类的顶级目录`。还可以创建一个符号链接指向其`驱动程序目录`。（尽管目前尚未实现，上面的总线、驱动程序都有链接到物理位置，单向是实现了，双向得看Linux版本history什么时候实现）


### 6. driver_register

`添加新驱动程序`时的过程几乎相同。会`遍历总线`上的设备列表以找到匹配项。`已拥有驱动程序的设备将被跳过`。会遍历所有设备，以便尽可能多地将设备绑定到该驱动程序。


### 7. Removal

当一个`设备被移除`时，其引用`计数最终会归零`。当引用计数为零时，会`调用驱动程序的移除回调函数`。该设备会从驱动程序的设备列表中移除，并且`驱动程序的引用计数会减一`。两者之间的`所有符号链接都会被移除`。

当`移除一个驱动程序`时，会`遍历它所支持的设备列表`，并`为每个设备调用驱动程序的移除回调函数`。设备会从该列表中移除，同时符号链接也会被删除。



## Bus Type 结构

### Bus 结构体定义


```c
// include/linux/device.h
struct bus_type {
	const char		*name;              // bus 名
	const char		*dev_name;          // 用于子系统枚举设备的表达式，如 `sprint(buffer, "foo%u", dev->id)`
	struct device		*dev_root;      // 用作父(设备)的默认设备。
	const struct attribute_group **bus_groups;      // 总线的默认属性。
	const struct attribute_group **dev_groups;      // 总线上设备的默认属性。
	const struct attribute_group **drv_groups;      // 总线上设备驱动的默认属性。

	int (*match)(struct device *dev, struct device_driver *drv);		// 驱动和设备的匹配函数：每当为该总线添加新设备或驱动程序时，可能会多次调用此函数。如果给定的驱动程序可以处理给定的设备，则应返回一个正值，否则返回零。如果无法确定驱动程序是否支持该设备，它也可能返回错误代码。如果返回 -EPROBE_DEFER ，则会将该设备排队等待延迟探测。
	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);		// 当设备添加、移除或发生其他一些会生成 uevent 的情况时调用，以便添加环境变量。uevent 是 Linux 内核中用于实现内核空间与用户空间通信的一种机制，主要用于通知用户空间关于硬件设备的状态变化（如设备插入、移除、属性变更等）。它是 Linux 设备模型（Device Model）的重要组成部分，属于 热插拔事件（Hotplug Events） 的一种实现方式。
	int (*probe)(struct device *dev);			// 当有`新设备或驱动程序`添加到该总线时调用此函数，并回调特定驱动程序的探测函数以初始化匹配的设备。
	int (*remove)(struct device *dev);			// 当`设备`从该总线移除时调用。
	void (*shutdown)(struct device *dev);		// 在关机时调用，以使`设备进入静止状态`

	int (*online)(struct device *dev);			// 在设备离线后，调用此函数使设备重新上线。
	int (*offline)(struct device *dev);			// 调用此函数以使设备离线以便热移除。可能会失败。

	int (*suspend)(struct device *dev, pm_message_t state);		// 当此总线上的设备想要进入睡眠模式时调用。
	int (*resume)(struct device *dev);		// 调用此函数可使该总线上的设备退出睡眠模式。

	int (*num_vf)(struct device *dev);		// 调用此函数以查明该总线上的设备支持多少个`虚拟函数`。

	int (*dma_configure)(struct device *dev);		// 用于设置此总线上某个设备的直接内存访问（DMA）配置。

	const struct dev_pm_ops *pm;		// 此总线的电源管理操作，回调特定设备驱动程序的电源管理操作。

	const struct iommu_ops *iommu_ops;		// 该总线上特定于IOMMU的操作，用于将IOMMU驱动程序实现附加到总线上，并允许驱动程序执行总线特定的设置。

	struct subsys_private *p;			// 驱动程序核心的私有数据，只有驱动程序核心可以操作此数据。
	struct lock_class_key lock_key;		// 供锁验证器使用的锁类密钥

	bool need_parent_lock;				// 当探测或移除该总线上的设备时，设备核心是否应锁定该设备的父设备。
};

extern int __must_check bus_register(struct bus_type *bus);
```


### 声明一种 Bus

内核中的每种总线类型（PCI、USB 等）都应该声明一个这种类型的静态对象。它们必须初始化name字段，并且可以选择初始化匹配回调函数：

```c
// drivers/pci/pci-driver.c
struct bus_type pci_bus_type = {
	.name = "pci",
	.match = pci_bus_match,
	...
};
EXPORT_SYMBOL(pci_bus_type);
```

该结构体应通过头文件导出给驱动程序：

```c
extern struct bus_type pci_bus_type;
```


### 注册一种 Bus

当一个总线驱动程序初始化时，它会调用 `bus_register`。这会初始化总线对象中的其余字段，并将其插入到全局总线类型列表中。一旦总线对象注册完成，总线驱动程序就可以使用其中的字段。

```c
// include/linux/device.h
extern int __must_check bus_register(struct bus_type *bus);

// drivers/base/bus.c
int bus_register(struct bus_type *bus){}
```


### Bus 相关回调函数

#### match()

设备ID结构的格式以及比较它们的语义本质上是特定于总线的。

`驱动程序`通常会声明一个`数组`，该数组包含它们`所支持的`、位于`特定于总线`的`驱动程序结构`中的`设备的设备ID`。

匹配回调的目的是`让总线有机会通过将驱动程序支持的设备ID与特定设备的设备ID进行比较`，来`确定特定驱动程序是否支持特定设备`，同时又不牺牲总线特定的功能或类型安全性。

当一个`驱动程序`在`总线上注册时`，会遍历总线的设备列表，并对每个`没有关联驱动程序`的设备调用匹配回调函数。

```
int (*match)(struct device *dev, struct device_driver *drv);		// return > 0 if matched else <=0, <0 is error code
```


### Bus 设备与驱动程序列表

设备列表和驱动程序列表旨在取代许多总线维护的本地列表。

它们分别是结构体`设备列表`和结构体设备`驱动程序列表`。`总线驱动程序`可随意使用这些列表，但可能需要`转换为特定于总线的类型`。

LDM (Linux Device Model) 核心提供了用于遍历每个列表的辅助函数：

```c
// include/linux/device.h
// drivers/base/bus.c
int bus_for_each_dev(struct bus_type * bus, struct device * start,
                     void * data, int (*fn)(struct device *, void *));

int bus_for_each_drv(struct bus_type * bus, struct device_driver * start,
                     void * data, int (*fn)(struct device_driver *, void *));

/*
@bus：表示要遍历的总线类型。
@start: 表示迭代开始的设备/驱动。如果为NULL，则从列表的第一个设备/驱动开始。
@data：这是自定义的传递给回调函数的数据，可以是任何类型的信息，用于回调函数的处理。
@fn：这是对每个设备调用的回调函数。该函数应该接受一个设备/驱动指针和@data作为参数。

对每个设备调用@fn函数。如果@fn返回`非零值`，迭代将终止，并返回该值。这允许回调函数控制迭代过程，例如，如果找到特定设备，可以提前终止迭代。
*/
```

这些辅助函数会遍历相应的列表，并为列表中的每个设备或驱动程序调用回调函数。

所有的列表访问操作都会通过获取总线锁（当前为读锁）来进行同步。

在调用回调函数之前，列表中每个对象的引用计数会增加；在获取下一个对象之后，引用计数会减少。`调用回调函数时不会持有锁`。这意味着如果调用者需要保留设备信息，必须在回调函数中增加设备的引用计数，以防止设备在迭代结束前被释放。



### Bus 与 sysfs

有一个名为“bus”的顶级目录。

每个总线在总线目录中都有一个目录，以及两个默认目录：

```
/sys/bus/pci/
|-- devices
`-- drivers
```

向总线注册的驱动程序会在总线的驱动程序目录中获得一个目录：

```
/sys/bus/pci/
|-- devices
`-- drivers
    |-- Intel ICH
    |-- Intel ICH Joystick
    |-- agpgart
    `-- e100
```

在该类型总线上发现的每个设备，都会在总线的设备目录中创建一个符号链接，指向`物理层级结构`中该设备的目录：

```
/sys/bus/pci/
|-- devices
|   |-- 00:00.0 -> ../../../devices/pci0/00:00.0
|   |-- 00:01.0 -> ../../../devices/pci0/00:01.0
|   `-- 00:02.0 -> ../../../devices/pci0/00:02.0
`-- drivers
```


### Bus Attribute 属性导出

Bus 导出属性到用户空间 的 结构定义：

```c
// include/linux/device.h
struct bus_attribute {
	struct attribute	attr;
	ssize_t (*show)(struct bus_type *bus, char *buf);
	ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
};

// include/linux/sysfs.h
struct attribute {
	const char		*name;		// sysfs中的文件名
	umode_t			mode;		// sysfs中的文件的权限
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	bool			ignore_lockdep:1;
	struct lock_class_key	*key;
	struct lock_class_key	skey;
#endif
};
```

总线驱动程序可以使用`BUS_ATTR_RW`宏导出属性，该宏的工作方式与设备的`DEVICE_ATTR_RW`宏类似。例如，像这样的定义：

```c
static BUS_ATTR_RW(debug);
```

等同于声明：

```c
static bus_attribute bus_attr_debug;
```

然后，可以使用以下命令，在`总线`的`sysfs`目录中添加和删除该属性：

```c
// include/linux/device.h
// drivers/base/bus.c
int bus_create_file(struct bus_type *, struct bus_attribute *);
void bus_remove_file(struct bus_type *, struct bus_attribute *);
```



## Device Driver 设计模式

### 状态容器

虽然内核包含一些设备驱动程序，这些驱动程序假定在某个特定系统上只会被探测（probe()）一次（单例），但通常会假定驱动程序绑定的设备会以`多个实例`的形式出现。这意味着`probe()函数`和`所有回调函数`都需要是`可重入的`。

实现这一点最常见的方法是使用`状态容器设计模式`。它通常具有以下形式：

```c
struct foo {
    spinlock_t lock; /* Example member， 不用太过关注 */
    (...)
};

static int foo_probe(...)
{
    struct foo *foo;

    foo = devm_kzalloc(dev, sizeof(*foo), GFP_KERNEL);  // 设备关联内存分配函数，属于 devm_ 系列函数（Device-Managed Resources）。它分配的内存会被注册到设备 dev 的资源管理列表中，内核会自动跟踪这些内存。当设备 dev 被卸载（如驱动移除）或销毁时，内核会自动释放所有与该设备绑定的内存，无需驱动开发者手动调用 kfree。避免内存泄漏。
    if (!foo)
        return -ENOMEM;
    spin_lock_init(&foo->lock);
    (...)
}
```

每次调用probe()时，这将在内存中创建一个struct foo实例。这是`此设备驱动程序实例`的状态容器。当然，随后有必要始终将此状态实例传递给所有需要访问该状态及其成员的函数。

例如，如果驱动程序正在注册一个中断处理程序，你可以像这样传递一个指向 `struct foo` 的指针：

```c
static irqreturn_t foo_handler(int irq, void *arg)
{
    struct foo *foo = arg;
    (...)
}

static int foo_probe(...)
{
    struct foo *foo;

    (...)
    ret = request_irq(irq, foo_handler, 0, "foo", foo);
}
```

这样，在中断处理程序中，你总能获得指向foo正确实例的指针。



### container_of() - 获取结构体成员所在的结构体(容器)指针

参照上述的 “状态容器” 举例，添加一项中断卸载任务时：

```c
struct foo {
    spinlock_t lock;
    struct workqueue_struct *wq;  // 不能使用这种指针类型的成员来进行container_of定位foo结构体地址
    struct work_struct offload;
    (...)
};

static void foo_work(struct work_struct *work)
{
    struct foo *foo = container_of(work, struct foo, offload);

    (...)
}

static irqreturn_t foo_handler(int irq, void *arg)
{
    struct foo *foo = arg;

    queue_work(foo->wq, &foo->offload);
    (...)
}

static int foo_probe(...)
{
    struct foo *foo;

    foo->wq = create_singlethread_workqueue("foo-wq");
    INIT_WORK(&foo->offload, foo_work);
    (...)
}
```

对于高精度定时器（hrtimer）或类似的东西，其设计模式是相同的，它们将在回调函数中返回`单个参数`，该参数是指向`结构体成员的指针`。

`container_of()` 的作用是，使用标准C中的 `offsetof()` 宏，通过简单的减法运算，从指向成员的指针`获取`指向包含该成员的`结构体的指针`，这使得（代码）能够实现类似于`面向对象`的行为。请注意，被包含的`成员不能是指针`，而`必须是实际的成员`，此方法才能奏效。container_of 实际上是一个宏定义。

通过这种方式，我们避免了使用指向结构体`foo *instance`的全局指针，同时仍将传递给foo_work工作函数的参数数量保持为单个指针。



## Device 结构

### Device 结构体定义

```c
// include/linux/device.h
struct device {
	struct kobject kobj;			// 所属的内核对象，一个顶层抽象类，其他类从中派生而来。
	struct device		*parent;	// 该设备的“父”设备，即它所连接的设备。在大多数情况下，父设备是某种总线或主机控制器。如果父设备为NULL，则该设备是顶级设备，这通常不是你想要的。

	struct device_private	*p;		// 保存*设备驱动*核心部分的私有数据。详细信息请参阅结构体 device_private 的注释。

	const char		*init_name; 	// 设备的初始名称。
	const struct device_type *type;	// 设备的类型。这用于识别设备类型并携带特定类型的信息。

	struct bus_type	*bus;			// 所在的总线的类型
	struct device_driver *driver;	// 被分配的**设备驱动**
	void		*platform_data;		// 特定于设备的平台数据，设备核心不应该接触它。
	void		*driver_data;		// 用于驱动程序特定信息的私有指针。驱动数据，通过 dev_set_drvdata/dev_get_drvdata 设置和获取
#ifdef CONFIG_PROVE_LOCKING
	struct mutex		lockdep_mutex;
#endif
	struct mutex		mutex;		// 用于同步对其驱动程序调用的互斥锁。mutex to synchronize calls to its driver.

	struct dev_links_info	links;	// 该设备供应商和消费者的链接。
	struct dev_pm_info	power;		// 用于设备电源管理。详情请参阅设备电源管理基础。
	struct dev_pm_domain	*pm_domain;		// 提供在系统挂起、休眠、系统恢复以及运行时电源管理转换期间执行的回调，同时提供子系统级和驱动程序级回调。

#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN
	struct irq_domain	*msi_domain;	/* 高版本移除 */
#endif
#ifdef CONFIG_ENERGY_MODEL;
    struct em_perf_domain   *em_pd; /* 设备的能量模型性能域， 高版本，5.10无 */
#endif;
#ifdef CONFIG_PINCTRL
	struct dev_pin_info	*pins;		/* 对于设备引脚管理。详情请参阅 PINCTRL（引脚控制）子系统。 */
#endif
#ifdef CONFIG_GENERIC_MSI_IRQ
	raw_spinlock_t		msi_lock;
	struct list_head	msi_list;
#endif

	struct dev_msi_info     msi;	// MSI相关数据

#ifdef CONFIG_ARCH_HAS_DMA_OPS;		// 高版本添加的编译选项，5.10无
	const struct dma_map_ops *dma_ops;	/* 此设备的DMA映射操作。 */
#endif;
	u64		*dma_mask;	/* dma mask (if dma'able device) */
	u64		coherent_dma_mask;/* Like dma_mask, but for
					     alloc_coherent mappings as
					     not all hardware supports
					     64 bit addresses for consistent
					     allocations such descriptors. */
	u64		bus_dma_mask;	/* upstream dma_mask constraint */
	unsigned long	dma_pfn_offset;

	struct device_dma_parameters *dma_parms;

	struct list_head	dma_pools;	/* dma pools (if dma'ble) */

#ifdef CONFIG_DMA_DECLARE_COHERENT
	struct dma_coherent_mem	*dma_mem; /* internal for coherent mem
					     override */
#endif
#ifdef CONFIG_DMA_CMA
	struct cma *cma_area;		/* contiguous memory area for dma
					   allocations */
#endif
	/* arch specific additions */
	struct dev_archdata	archdata;

	struct device_node	*of_node; /* associated device tree node */
	struct fwnode_handle	*fwnode; /* firmware device node */

#ifdef CONFIG_NUMA
	int		numa_node;	/* NUMA node this device is close to */
#endif
	dev_t			devt;	/* dev_t, creates the sysfs "dev" */
	u32			id;	/* device instance */

	spinlock_t		devres_lock;
	struct list_head	devres_head;

	struct class		*class;
	const struct attribute_group **groups;	/* optional groups */

	void	(*release)(struct device *dev);
	struct iommu_group	*iommu_group;
	struct iommu_fwspec	*iommu_fwspec;
	struct iommu_param	*iommu_param;

	bool			offline_disabled:1;
	bool			offline:1;
	bool			of_node_reused:1;
#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \
    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \
    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)
	bool			dma_coherent:1;
#endif
};
```





### Device 编程接口

#### 注册设备

`发现设备`的`总线驱动程序`使用此函数向内核`注册该设备`：

```c
// include/linux/device.h
// drivers/base/core.c
int device_register(struct device * dev);
```

总线应初始化以下字段：

- parent 父设备
- name 名称
- bus_id 总线ID
- bus 总线

#### 调整设备引用

当设备的引用计数变为0时，它将从核心中移除。可以使用以下方式调整引用计数：

```c
// include/linux/device.h
// drivers/base/core.c
struct device * get_device(struct device * dev);
void put_device(struct device * dev);  // 释放引用
```

如果引用尚未为0（如果它已在被移除的过程中，即为被完成移除时，引用尚未为0），`get_device()` 将返回一个指向传递给它的 `struct device` 的指针。

#### 设备结构上锁

驱动程序可以使用以下方式访问设备结构中的锁：

```c
void lock_device(struct device * dev);
void unlock_device(struct device * dev);
```


### Device Attribute 属性导出

```c
// include/linux/device.h
struct device_attribute {
      struct attribute        attr;
      ssize_t (*show)(struct device *dev, struct device_attribute *attr,
                      char *buf);
      ssize_t (*store)(struct device *dev, struct device_attribute *attr,
                       const char *buf, size_t count);
};
```

设备的属性可以由设备驱动程序通过sysfs导出。

As explained in Everything you never wanted to know about kobjects, ksets, and ktypes, device attributes must be created before the KOBJ_ADD uevent is generated. The only way to realize that is by defining an attribute group.

设备属性必须在生成KOBJ_ADD用户事件之前创建。实现这一点的唯一方法是定义一个属性组。

属性使用名为`DEVICE_ATTR`的宏进行声明：

```c
// include/linux/device.h
#define DEVICE_ATTR(name,mode,show,store)
// Example:: 示例::
static DEVICE_ATTR(type, 0444, type_show, NULL);
static DEVICE_ATTR(power, 0644, power_show, power_store);
```

这声明了上述两个类型为 struct device_attribute 的结构体，分别名为“dev_attr_type”和“dev_attr_power”。这两个属性可以按如下方式组织成一个组（`单组`）：

```c
static struct attribute *dev_attrs[] = {
      &dev_attr_type.attr,
      &dev_attr_power.attr,
      NULL,
};

static struct attribute_group dev_group = {
      .attrs = dev_attrs,
};

static const struct attribute_group *dev_groups[] = {
      &dev_group,
      NULL,
};
```

对于`单组`的常见情况，有一个辅助宏可用，因此上述两个结构可以使用以下方式声明：

```c
// include/linux/sysfs.h
ATTRIBUTE_GROUPS(dev);
// 原理如下：
#define __ATTRIBUTE_GROUPS(_name)				\
static const struct attribute_group *_name##_groups[] = {	\
	&_name##_group,						\
	NULL,							\
}

#define ATTRIBUTE_GROUPS(_name)					\
static const struct attribute_group _name##_group = {		\
	.attrs = _name##_attrs,					\
};								\
__ATTRIBUTE_GROUPS(_name)
```

然后，在调用 `device_register()` 之前，通过在 struct device 中设置组指针，可将这组数组与设备关联起来：

```c
dev->groups = dev_groups;
device_register(dev);
```

`device_register()`函数将使用“groups”指针来创建设备属性，而`device_unregister()`函数将使用该指针来删除设备属性。

警告：虽然内核允许在任何时候对设备调用`device_create_file()`和`device_remove_file()`，但用户空间对何时创建属性有严格的预期。当在内核中注册一个新设备时，会生成一个uevent来通知用户空间（如udev）有新设备可用。`如果在设备注册后添加属性，那么用户空间将不会收到通知，也就不会知道新的属性`。

这对于那些需要在驱动探测时为设备发布额外属性的设备驱动程序很重要。如果设备驱动程序只是对传递给它的设备结构简单调用 device_create_file()，那么用户空间将永远不会收到有关新属性的通知。



## Devres Device资源管理与托管

### 简介

Devres的出现，是处于 libata 迁移 iomap 时暴露的资源管理问题 的情况下。每个iomap映射的地址都应在驱动程序分离时保留并取消映射。例如，一个普通的SFF ATA控制器（即老式的PCI IDE）在原生模式下使用5个PCI基址寄存器（BAR），所有这些都应予以维护。

与许多其他设备驱动程序一样，libata 底层驱动程序在 ->remove 和 ->probe 失败路径方面存在足够多的漏洞。嗯，没错，这可能是因为 libata 底层驱动程序开发者比较懒，但底层驱动程序开发者不都这样吗？在花费一整天时间摆弄那些没有文档说明或者文档乱七八糟的损坏硬件之后，如果它最终能正常工作，那就行了。

由于这样或那样的原因，底层驱动程序没有像核心代码那样受到足够的关注或测试，而且驱动程序分离或初始化失败的错误发生得不够频繁，不足以引起注意。初始化失败的情况更糟糕，因为它很少出现，但却需要处理多个入口点。

因此，许多低级驱动程序在驱动分离时最终会泄漏资源，并且在 ->probe() 中有不完善的故障处理路径实现，这会在发生故障时导致资源泄漏甚至引发内核错误。iomap 使这种情况更加复杂。MSI 和 MSIX 也是如此。

通过自动化资源释放和简化驱动代码，devres 从根本上提升了内核驱动的可靠性和可维护性。



### Devres

`devres`本质上是一个`链表`，包含与`struct device`关联的`任意大小的内存区域`。每个devres项都关联一个`释放函数`。devres可以通过多种方式释放。无论如何，所有devres项都会在驱动程序分离时释放。释放时，会调用关联的释放函数，然后释放devres项。

使用devres为设备驱动程序常用的资源创建了托管接口。例如，使用`dma_alloc_coherent()`获取一致性DMA内存。`托管版本`称为`dmam_alloc_coherent()`。它与dma_alloc_coherent()完全相同，只是使用`它分配的DMA内存是受管理的`，并且在`驱动程序分离`时将`自动释放`。实现如下：

```c
// kernel/dma/mapping.c
struct dma_devres {
	size_t          size;
	void            *vaddr;
	dma_addr_t      dma_handle;
	unsigned long	attrs;
};

static void dmam_coherent_release(struct device *dev, void *res)
{
	struct dma_devres *this = res;

	dma_free_coherent(dev, this->size, this->vaddr, this->dma_handle);
}

dmam_alloc_coherent(dev, size, dma_handle, gfp)
{
	struct dma_devres *dr;
	void *vaddr;

	dr = devres_alloc(dmam_coherent_release, sizeof(*dr), gfp);
	...

	/* alloc DMA memory as usual */
	vaddr = dma_alloc_coherent(...);
	...

	/* record size, vaddr, dma_handle in dr */
	dr->vaddr = vaddr;
	...

	devres_add(dev, dr);

	return vaddr;
}
```

如果驱动程序使用`dmam_alloc_coherent()`，无论初始化`中途失败`还是`设备被分离`，都能`保证该区域被释放`。如果大多数资源是通过托管接口获取的，驱动程序的初始化和退出代码可以简单得多。初始化流程基本如下：

```c
my_init_one()
{
	struct mydev *d;

	d = devm_kzalloc(dev, sizeof(*d), GFP_KERNEL);
	if (!d)
			return -ENOMEM;

	d->ring = dmam_alloc_coherent(...);
	if (!d->ring)
			return -ENOMEM;

	if (check something)
			return -EINVAL;
	...

	return register_to_upper_layer(d);  // 伪代码
}
```

退出流程：

```c
my_remove_one()
{
	unregister_from_upper_layer(d);  // 伪代码
	shutdown_my_hardware();  // 伪代码
}
```

如上所示，通过使用devres，底层驱动程序可以大大简化。复杂性从维护较少的底层驱动程序转移到维护更好的高层。此外，由于初始化失败路径与退出流程相同，两者都可以得到更多测试。

注意，在将当前调用或赋值转换为托管的 `devm_*` 版本时，需要您`自行检查`诸如`内存分配`之类的内部操作`是否失败`。托管资源`仅`涉及这些资源的释放（着重强调“仅”），所有其他必要的检查仍由您负责。在某些情况下，这可能意味着要引入在迁移到托管的devm_* 调用之前并非必要的检查。


### Devres Group

设备资源项（devres entries）可以使用设备资源组（devres group）进行分组。当一个组被释放时，所有包含的普通设备资源项以及正确嵌套的组`都会被释放`。一种用途是在出现故障时回滚一系列已获取的资源。例如：

```c
	if (!devres_open_group(dev, NULL, GFP_KERNEL))  // drivers/base/devres.c
		return -ENOMEM;

	acquire A;
	if (failed)
		goto err;

	acquire B;
	if (failed)
		goto err;
	...

	devres_remove_group(dev, NULL);
	return 0;

err:
	devres_release_group(dev, NULL);
	return err_code;
```

由于`资源获取失败`通常意味着`探测失败`，上述这样的结构通常在`中层驱动程序`（例如libata核心层）中很有用，在这些地方，接口函数在失败时不应产生副作用。对于底层驱动程序（`LLD`），在大多数情况下，仅返回错误代码就足够了。

每个组由 `void *id` 标识。（1）它既可以通过 `devres_open_group()` 的 `@id` 参数`显式指定`，也可以像上面的示例那样，（2）通过将 `NULL` 作为 `@id` 传入来`自动创建`。在这两种情况下，devres_open_group() 都会返回组的 ID。返回的 ID 可以传递给其他设备资源管理函数，以选择目标组。`如果将 NULL 传递给这些函数，则会选择最新打开的组`。

例如，可以进行如下操作：

```c
int my_midlayer_create_something()
{
      if (!devres_open_group(dev, my_midlayer_create_something, GFP_KERNEL))  // my_midlayer_create_something 所在函数地址
              return -ENOMEM;

      ...

      devres_close_group(dev, my_midlayer_create_something);
      return 0;
}

void my_midlayer_destroy_something()
{
      devres_release_group(dev, my_midlayer_create_something);
}
```


### Devres 细节

- 不涉及引用计数：devres条目的生命周期从devres分配开始，到其被释放或销毁（移除并释放）时结束，`不涉及引用计数`。

- 原子性：devres核心保证了所有基本devres操作的`原子性`，并`支持单实例devres类型`（`原子查找并在未找到时添加`）。除此之外，对已分配的devres数据的并发访问进行同步是调用者的责任。这通常不是问题，因为总线操作和资源分配已经完成了这项工作。

- 单实例devres类型示例：阅读`lib/devres.c`中的`pcim_iomap_table()`。

- 如果给定了正确的 GFP 掩码，所有 devres 接口函数都可以在无上下文的情况下调用。



### Devres 开销

每个设备资源 bookkeeping 信息与`请求的数据区域`一起分配。当调试选项关闭时，bookkeeping 信息在32位机器上占用16字节，在64位机器上占用24字节（三个指针向上舍入到无符号长整型对齐）。如果使用单链表，它可以减少到两个指针（32位上为8字节，64位上为16字节）。

每个设备资源组占用8个指针。如果使用单链表，可减少到6个。

在32位机器上，经过简单转换后，具有两个端口的ahci控制器的内存空间开销在300到400字节之间（我们当然可以在libata核心层上多花些功夫）。


### Devres 托管接口列表

#### CLOCK
devm_clk_get() devm_clk_get_optional() devm_clk_put() devm_clk_bulk_get() devm_clk_bulk_get_all() devm_clk_bulk_get_optional() devm_get_clk_from_child() devm_clk_hw_register() devm_of_clk_add_hw_provider() devm_clk_hw_register_clkdev()

#### DMA
dmaenginem_async_device_register() dmam_alloc_coherent() dmam_alloc_attrs() dmam_free_coherent() dmam_pool_create() dmam_pool_destroy()

#### DRM
devm_drm_dev_alloc()

#### GPIO
devm_gpiod_get() devm_gpiod_get_array() devm_gpiod_get_array_optional() devm_gpiod_get_index() devm_gpiod_get_index_optional() devm_gpiod_get_optional() devm_gpiod_put() devm_gpiod_unhinge() devm_gpiochip_add_data() devm_gpio_request() devm_gpio_request_one()

#### I2C
devm_i2c_add_adapter() devm_i2c_new_dummy_device()

#### IIO
devm_iio_device_alloc() devm_iio_device_register() devm_iio_dmaengine_buffer_setup() devm_iio_kfifo_buffer_setup() devm_iio_kfifo_buffer_setup_ext() devm_iio_map_array_register() devm_iio_triggered_buffer_setup() devm_iio_triggered_buffer_setup_ext() devm_iio_trigger_alloc() devm_iio_trigger_register() devm_iio_channel_get() devm_iio_channel_get_all() devm_iio_hw_consumer_alloc() devm_fwnode_iio_channel_get_by_name()

#### INPUT
devm_input_allocate_device()

#### IO region
devm_release_mem_region() devm_release_region() devm_release_resource() devm_request_mem_region() devm_request_free_mem_region() devm_request_region() devm_request_resource()

#### IOMAP
devm_ioport_map() 
devm_ioport_unmap() 
devm_ioremap() 
devm_ioremap_uc() 
devm_ioremap_wc() 
devm_ioremap_resource() : checks resource, requests memory region, ioremaps 
devm_ioremap_resource_wc() 
devm_platform_ioremap_resource() : calls devm_ioremap_resource() for platform device 
devm_platform_ioremap_resource_byname() 
devm_platform_get_and_ioremap_resource() 
devm_iounmap()

Note: For the PCI devices the specific pcim_*() functions may be used, see below.

#### IRQ
devm_free_irq() devm_request_any_context_irq() devm_request_irq() devm_request_threaded_irq() devm_irq_alloc_descs() devm_irq_alloc_desc() devm_irq_alloc_desc_at() devm_irq_alloc_desc_from() devm_irq_alloc_descs_from() devm_irq_alloc_generic_chip() devm_irq_setup_generic_chip() devm_irq_domain_create_sim()

#### LED
devm_led_classdev_register() devm_led_classdev_register_ext() devm_led_classdev_unregister() devm_led_trigger_register() devm_of_led_get()

#### MDIO
devm_mdiobus_alloc() devm_mdiobus_alloc_size() devm_mdiobus_register() devm_of_mdiobus_register()

#### MEM
devm_free_pages() devm_get_free_pages() devm_kasprintf() devm_kcalloc() devm_kfree() devm_kmalloc() devm_kmalloc_array() devm_kmemdup() devm_krealloc() devm_krealloc_array() devm_kstrdup() devm_kstrdup_const() devm_kvasprintf() devm_kzalloc()

#### MFD
devm_mfd_add_devices()

#### MUX
devm_mux_chip_alloc() devm_mux_chip_register() devm_mux_control_get() devm_mux_state_get()

#### NET
devm_alloc_etherdev() devm_alloc_etherdev_mqs() devm_register_netdev()

#### PER-CPU MEM
devm_alloc_percpu() devm_free_percpu()

#### PCI
devm_pci_alloc_host_bridge() : managed PCI host bridge allocation 
devm_pci_remap_cfgspace() : ioremap PCI configuration space 
devm_pci_remap_cfg_resource() : ioremap PCI configuration space resource

pcim_enable_device() : after success, the PCI device gets disabled automatically on driver detach 
pcim_iomap() : do iomap() on a single BAR 
pcim_iomap_regions() : do request_region() and iomap() on multiple BARs 
pcim_iomap_table() : array of mapped addresses indexed by BAR 
pcim_iounmap() : do iounmap() on a single BAR 
pcim_pin_device() : keep PCI device enabled after release 
pcim_set_mwi() : enable Memory-Write-Invalidate PCI transaction

#### PHY
devm_usb_get_phy() devm_usb_get_phy_by_node() devm_usb_get_phy_by_phandle()

PINCTRL
devm_pinctrl_get() devm_pinctrl_put() devm_pinctrl_get_select() devm_pinctrl_register() devm_pinctrl_register_and_init() devm_pinctrl_unregister()

#### POWER
devm_reboot_mode_register() devm_reboot_mode_unregister()

#### PWM
devm_pwmchip_alloc() devm_pwmchip_add() devm_pwm_get() devm_fwnode_pwm_get()

#### REGULATOR
devm_regulator_bulk_register_supply_alias() devm_regulator_bulk_get() devm_regulator_bulk_get_const() devm_regulator_bulk_get_enable() devm_regulator_bulk_put() devm_regulator_get() devm_regulator_get_enable() devm_regulator_get_enable_read_voltage() devm_regulator_get_enable_optional() devm_regulator_get_exclusive() devm_regulator_get_optional() devm_regulator_irq_helper() devm_regulator_put() devm_regulator_register() devm_regulator_register_notifier() devm_regulator_register_supply_alias() devm_regulator_unregister_notifier()

#### RESET
devm_reset_control_get() devm_reset_controller_register()

#### RTC
devm_rtc_device_register() devm_rtc_allocate_device() devm_rtc_register_device() devm_rtc_nvmem_register()

#### SERDEV
devm_serdev_device_open()

#### SLAVE DMA ENGINE
devm_acpi_dma_controller_register()

#### SPI
devm_spi_alloc_host() devm_spi_alloc_target() devm_spi_optimize_message() devm_spi_register_controller() devm_spi_register_host() devm_spi_register_target()

#### WATCHDOG
devm_watchdog_register_device()



## Device Driver 结构

### Device Driver 结构体定义

设备驱动程序模型会跟踪系统已知的所有驱动程序。进行这种跟踪的主要原因是使驱动程序核心能够将驱动程序与新设备进行匹配。不过，一旦驱动程序成为系统中的已知对象，就可以实现许多其他功能。设备驱动程序可以导出独立于任何特定设备的信息和配置变量。

```c
// include/linux/device.h
struct device_driver {
	const char		*name;		// 设备驱动程序的名称。
	struct bus_type		*bus;	// 该驱动程序所对应的设备所属的总线。

	struct module		*owner;										// 模块所有者。
	const char		*mod_name;	/* used for built-in modules */		// 用于内置模块。

	bool suppress_bind_attrs;	/* disables bind/unbind via sysfs */	// 禁止通过sysfs进行绑定/解绑操作。
	enum probe_type probe_type;											// 要使用的探测类型（同步或异步）。

	const struct of_device_id	*of_match_table;					// The open firmware table. 开放固件匹配表。
	const struct acpi_device_id	*acpi_match_table;					// The ACPI match table. ACPI匹配表。ACPI，高级配置和电源接口。

	int (*probe) (struct device *dev);			// 用于查询特定设备是否存在，判断此驱动程序是否可与之协同工作，并将驱动程序绑定到特定设备。
	void (*sync_state)(struct device *dev);		// 在所有与该设备关联的状态跟踪使用者（在late_initcall时存在）成功绑定到驱动程序后，调用此函数将设备状态同步到软件状态。如果设备没有使用者，此函数将在late_initcall_sync级别被调用。如果设备的使用者从未绑定到驱动程序，则在它们绑定之前，此函数永远不会被调用。高版本，5.10无。
	int (*remove) (struct device *dev);			// 当设备从系统中移除时调用，用于将设备与该驱动解除绑定。
	void (*shutdown) (struct device *dev);		// 在关机时调用，以使设备停止运行。
	int (*suspend) (struct device *dev, pm_message_t state);	// 调用此函数将设备置于睡眠模式。通常是为了降低功耗。
	int (*resume) (struct device *dev);			// 用于将设备从睡眠模式唤醒。
	const struct attribute_group **groups;		// 由驱动程序核心自动创建的默认属性。
	const struct attribute_group **dev_groups;	// 设备实例绑定到驱动程序后附加的其他属性。

	const struct dev_pm_ops *pm;				// 匹配此驱动程序的设备的电源管理操作。
	void (*coredump) (struct device *dev);		// 当写入sysfs条目时调用。预计设备驱动程序将调用 dev_coredump API，从而产生一个 uevent。

	struct driver_private *p;					// 驱动核心的私有数据，除了驱动核心之外，任何人都不能触碰。
};


extern int __must_check driver_register(struct device_driver *drv);
extern void driver_unregister(struct device_driver *drv);

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *driver, char *buf);
	ssize_t (*store)(struct device_driver *driver, const char *buf,
			 size_t count);
};
```


### Device Driver 分配与初始化

分配：设备驱动程序是`静态分配`的结构体。尽管一个系统中可能有`多个设备`由`某个驱动程序支持`，但 `struct device_driver` 代表的是`整个驱动程序`（而`非特定的设备实例`）。

初始化：驱动程序至少必须`初始化名称(name)`和`总线(bus)`字段。它还应初始化`设备类(devclass)`字段（当它可用时，旧版本内核！），以便在内部获得正确的链接。它还应尽可能多地初始化`回调函数`，尽管每个回调函数都是可选的。



### 声明一个 Device Driver

如上所述，struct device_driver 对象是`静态分配`的。以下是 eepro100 驱动程序的一个示例声明。此声明仅为假设；它依赖于`将驱动程序完全转换为新模型`：

```c
static struct device_driver eepro100_driver = {
       .name          = "eepro100",
       .bus           = &pci_bus_type,

       .probe         = eepro100_probe,
       .remove                = eepro100_remove,
       .suspend               = eepro100_suspend,
       .resume                = eepro100_resume,
};
```

`大多数驱动程序无法完全转换为新模型`，因为它们所属的总线具有`特定于总线`的结构和特定于总线的字段，这些`无法进行通用化处理`。

这种情况最常见的例子是`设备ID结构`。驱动程序通常会定义它所支持的`设备ID数组`。`这些结构的格式以及比较设备ID的语义完全特定于总线`。将它们定义为特定于总线的实体将牺牲类型安全性，因此我们`保留特定于总线的结构`。

特定总线驱动程序的定义中应包含通用的 struct device_driver。如下所示：

```c
struct pci_driver {
       const struct pci_device_id *id_table;
       struct device_driver     driver;
};
```

包含特定于总线的字段的定义可能如下（再次使用eepro100驱动程序）：

```c
static struct pci_driver eepro100_driver = {
       .id_table       = eepro100_pci_tbl,
       .driver               = {
              .name           = "eepro100",
              .bus            = &pci_bus_type,
              .probe          = eepro100_probe,
              .remove         = eepro100_remove,
              .suspend        = eepro100_suspend,
              .resume         = eepro100_resume,
       },
};
```

有些人可能会觉得嵌入式结构体初始化的语法很别扭，甚至有点难看。到目前为止，这是找到的实现目标的最佳方式。



### 注册一个 Device Driver

```c
// include/linux/device.h
// drivers/base/driver.c
int driver_register(struct device_driver *drv);
```

驱动程序在启动时注册该结构体。

对于`没有特定总线`字段（即没有特定总线驱动程序结构体）的驱动程序，它们将使用`driver_register`并传入指向其 `struct device_driver` 对象的`指针`。

然而，大多数驱动程序将具有特定于总线的结构，并且需要使用诸如`pci_driver_register`之类的函数`向总线注册`。

驱动程序开发人员应尽早注册其驱动程序结构，这一点很重要。向内核注册会初始化 struct device_driver 对象中的几个字段，包括引用`计数`和`锁`。这些字段在任何时候都被认为是有效的，并且可能会被`设备模型内核`或`总线驱动程序`使用。



### 通用 Driver 过渡到 Bus Driver

通过定义`包装函数`，可以更轻松地过渡到`新模型`。驱动程序可以完全`忽略通用结构`，让总线包装器填充字段。对于回调函数，总线可以定义`通用回调函数`，将调用转发给驱动程序`特定于总线的回调函数`。

这个解决方案只是`临时的`。为了在驱动程序中获取类信息，无论如何都必须对驱动程序进行修改。由于将驱动程序转换为新模型应该会降低一些基础设施的复杂性并减小代码规模，因此建议在添加类信息时进行转换。



### 访问 Device Driver

一旦对象被注册，它就可以访问对象的公共字段，比如锁和设备列表：

```c
int driver_for_each_dev(struct device_driver *drv, void *data,
                        int (*callback)(struct device *dev, void *data));

// include/linux/device.h
// drivers/base/driver.c
int driver_for_each_device(struct device_driver *drv, struct device *start,
			   void *data, int (*fn)(struct device *, void *))
```

`devices`字段是`所有`已绑定到驱动程序的`设备`的列表。LDM (Linux Device Model) 核心提供了一个辅助函数，用于对驱动程序控制的所有设备进行操作。此辅助函数在每次访问节点时`锁定驱动程序`，并在访问每个设备时对其进行`适当的引用计数`。



### Device Drvier 与 sysfs

当注册一个驱动程序时，会在其`总线目录`下创建一个`sysfs目录`。在这个目录中，驱动程序可以`向用户空间导出一个接口`，以便从全局角度控制驱动程序的操作；例如，切换驱动程序中的调试输出。

该目录未来的一项功能将是一个“devices”目录。此目录将包含指向它所支持的设备目录的符号链接。



### Device Driver 相关回调函数

#### probe()

```c
int (*probe)(struct device *dev);
```

`probe()` 入口在`任务上下文`中`被调用`，此时`总线的读写信号量已锁定`，且`驱动程序已部分绑定到设备`。在 probe() 及其他例程中，驱动程序通常使用 `container_of()` 将 `dev` `转换`为`特定于总线的类型`。该类型通常`提供设备资源数据`，例如 `pci_dev.resource[]` 或 `platform_device.resources`，这些数据与 `dev->platform_data` 一起`用于初始化驱动程序`。

此回调包含特定于驱动程序的逻辑，用于`将驱动程序绑定到给定设备`。这包括`验证设备是否存在`、`其版本是否为驱动程序可处理的版本`、`是否可以分配和初始化驱动程序数据结构`，以及`是否可以初始化任何硬件`。驱动程序通常使用 `dev_set_drvdata()` 存储 `指向其状态的指针`。当驱动程序成功将自身绑定到该设备时，probe() 将返回`零`，驱动程序模型代码将完成其将驱动程序绑定到该设备的部分工作。

驱动程序的probe()函数可能返回一个`负的errno值`，以表明驱动程序未绑定到该设备，在这种情况下，它`应释放已分配的所有资源`。

如果驱动程序`依赖的资源尚不可用`（例如，由尚未初始化的驱动程序提供的资源），probe() 函数可以选择返回 `-EPROBE_DEFER`。驱动程序核心会将设备`放入延迟探测列表`，并在`稍后尝试`再次调用该函数。如果驱动程序必须延迟，`应尽早`返回 `-EPROBE_DEFER`，以减少在设置工作上花费的时间，因为这些工作稍后需要回滚并重新执行。

Warning!!! 如果probe()`已经创建设备子项`，即便这些设备子项在清理过程中`又被移除`，也`一定不能`返回`-EPROBE_DEFER`。如果在注册设备子项后返回`-EPROBE_DEFER`，可能会导致`对同一驱动程序的probe()`调用`陷入无限循环`。


#### sync_state()

```c
void (*sync_state)(struct device *dev);
```

`sync_state` 对`一个设备仅调用一次`。当该设备的`所有消费类设备`都`成功探测`到时，就会`调用此函数`。设备的`消费类设备列表`是`通过查看将该设备连接到其消费类设备的设备链接来获取的`。

首次调用`sync_state()`是在`late_initcall_sync()`期间进行的，目的是`为固件和驱动程序留出时间，以便将设备相互连接`。在首次尝试调用`sync_state()`时，如果此时设备的所有使用者都已成功探测，就会立即调用`sync_state()`。如果在首次尝试时设备`没有使用者，这也会被视为“设备的所有使用者都已探测”`，并立即调用`sync_state()`。

如果在首次尝试为设备调用sync_state()时，仍有使用者未能成功探测，则sync_state()调用将`被推迟`，并且仅在该设备的一个或多个使用者成功探测后，才会在未来重新尝试调用。如果在重新尝试期间，驱动程序核心发现该设备仍有一个或多个使用者尚未探测，则sync_state()调用将再次被推迟。

sync_state()的一个典型用例是`让内核平稳地从引导加载程序接管设备管理`。例如，如果引导加载程序使设备处于开启状态并处于特定的硬件配置，设备驱动程序`可能需要将设备保持在引导配置`，直到设备的所有使用者都完成探测。一旦设备的`所有使用者都完成探测`，设备驱动程序就可以`同步设备的硬件状态`，以匹配所有使用者请求的聚合软件状态。这就是sync_state()名称的由来。

虽然可以从sync_state()中受益的资源的明显例子包括`regulator`调节器等资源，但sync_state()对`IOMMU`等复杂资源也很有用。例如，具有多个使用者（其地址由IOMMU重新映射的设备）的IOMMU可能需要将其映射固定在启动配置（或在`启动配置基础上添加`），直到其所有使用者都已探测完毕。

虽然`sync_state()`的典型用例是让内核从引导加载程序干净利落地接管设备管理，但`sync_state()`的使用并不局限于此。只要在设备的所有使用者探测完成后采取行动是合理的，就可以使用它。sync_state() 是内核控制的单向回调机制，驱动程序不能随时调用，仅能通过实现该函数定义具体逻辑，由内核在满足条件时自动触发。



#### remove()

```c
int (*remove)(struct device *dev);
```

调用remove函数是为了`将驱动程序与设备解除绑定`。当设备已从系统中物理移除、或驱动程序模块正在卸载、或系统重启过程中或其他情况下，都可能调用该函数。

`设备是否存在由驱动程序决定`。驱动程序`应释放为该设备专门分配的所有资源`，即设备的`driver_data`字段中的任何内容。

如果设备仍然存在，它应使设备`进入静止状态`，并将其置于支持的`低功耗状态`。


#### suspend()

```c
int (*suspend)(struct device *dev, pm_message_t state);
```

调用suspend将设备置于低功耗状态。



#### resume()

```c
int (*resume)(struct device *dev);
```

恢复用于将设备从低功耗状态恢复。



### Drvier Attribute 属性导出

设备驱动程序可以通过其sysfs目录导出属性。驱动程序可以使用`DRIVER_ATTR_RW`和`DRIVER_ATTR_RO`宏声明属性，其工作方式与`DEVICE_ATTR_RW`和`DEVICE_ATTR_RO`宏完全相同。

示例：
```c
DRIVER_ATTR_RW(debug);
```

这等效于声明：
```c
struct driver_attribute driver_attr_debug;
```

然后，可以使用以下方式`在驱动程序目录中添加和删除该属性`：

```c
int driver_create_file(struct device_driver *, const struct driver_attribute *);
void driver_remove_file(struct device_driver *, const struct driver_attribute *);
```



## Linux 内核设备模型

### 概述

Linux内核驱动模型是`对之前在内核中使用的所有不同驱动模型的统一`。它旨在`通过将一组数据和操作整合到全局可访问的数据结构中`，来`增强针对桥接器和设备的特定总线驱动程序`。

`传统的驱动程序模型`为它们`所控制的设备`实现了`某种树状结构`（有时只是一个列表）。不同总线类型之间没有任何一致性。

`当前的驱动模型`提供了一个`通用、统一的数据模型`，用于`描述总线以及可能出现在该总线下的设备`。统一的总线模型包含一组`所有总线`都具备的`通用属性`，以及一组`通用回调函数`，例如在总线探测期间的`设备发现`、`总线关闭`、`总线电源管理`等。

通用设备和桥接接口体现了现代计算机的目标：即实现设备无缝`即插即用`、`电源管理`和`热插拔`的能力。特别是英特尔和微软制定的模型（即ACPI）确保了x86兼容系统上几乎任何总线上的几乎每一个设备都能在这种模式下工作。当然，并非每条总线都能支持所有这些操作，尽管大多数总线支持其中的大部分操作。



### 下游访问

首先要注意，`struct pci_dev` 中的 `struct device` 结构体 `dev` 是静态分配的。这意味着在设备发现时仅进行一次分配。







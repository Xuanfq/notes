# 驱动模型

Refer:

- [Driver implementer’s API guide — The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/driver-api/index.html)
- [Driver Model — The Linux Kernel documentation](https://www.kernel.org/doc/html/latest/driver-api/driver-model/index.html)


## Driver 绑定

驱动程序绑定是将设备与能够控制它的设备驱动程序相关联的过程。通常由`总线驱动程序来处理这个问题`，因为一直存在特定于总线的结构来表示设备和驱动程序。有了通用的设备和设备驱动程序结构，大部分绑定都可以使用通用代码来完成。

### 1. Bus

`Bus` 包含:
- `Device`: 由 `device_register` 插入 Bus 列表
- `Driver`: 由 `driver_register` 插入 Bus 列表

总线类型结构包含系统中该总线类型上所有设备的列表。

当为某个设备调用device_register时，该设备会被插入到此列表的末尾。

总线对象还包含该总线类型所有驱动程序的列表。

当为某个驱动程序调用driver_register时，该驱动程序会被插入到此列表的末尾。这两个事件会触发驱动程序绑定。


### 2. device_register

当`添加新设备`时，会遍历总线的驱动程序列表，以找到一个支持该设备的驱动程序。

为了确定这一点，设备的设备ID必须与驱动程序支持的设备ID之一相匹配。比较ID的格式和语义因总线而异。

与其尝试推导复杂的状态机和匹配算法，不如由总线`驱动程序`提供一个`回调函数`(`.match`)，将设备与驱动程序的ID进行比较。如果找到匹配项，总线返回1；否则返回0。

```
int match(struct device * dev, struct device_driver * drv);
```

如果找到匹配项，设备的驱动程序字段将`设置为该驱动程序`，并且会`调用驱动程序的探测回调函数`(`.probe`)。这使驱动程序有机会验证其`是否真正支持该硬件`，以及该`硬件是否处于工作状态`。


### 3. Device Class

在成功完成`探测`(`.probe`)后，`设备`会向其`所属的类`注册。设备驱动程序只属于一个类，这个类在`驱动程序`的`devclass`字段中设置。调用`devclass_add_device`函数在类中枚举设备，并通过类的`register_dev`回调函数`实际向该类注册设备`。


### 4. Driver

当一个驱动程序附加到一个设备时，该设备会被插入到驱动程序的设备列表中。


### 5. sysfs

在`总线`的“devices”目录中会创建一个`符号链接`，它指向`物理层级结构中设备的目录`。

在`驱动程序`的“devices”目录中会创建一个`符号链接`，它指向`物理层级结构中设备的目录`。

在`类的目录`中会为该设备创建一个目录。在该目录中会创建一个`符号链接`，它指向该设备在`sysfs树中的物理位置`。

可以在设备的`物理目录`中创建一个`符号链接`，该符号链接可以指向其`类目录`，也可以指向`该类的顶级目录`。还可以创建一个符号链接指向其`驱动程序目录`。（尽管目前尚未实现，上面的总线、驱动程序都有链接到物理位置，单向是实现了，双向得看Linux版本history什么时候实现）


### 6. driver_register

`添加新驱动程序`时的过程几乎相同。会`遍历总线`上的设备列表以找到匹配项。`已拥有驱动程序的设备将被跳过`。会遍历所有设备，以便尽可能多地将设备绑定到该驱动程序。


### 7. Removal

当一个`设备被移除`时，其引用`计数最终会归零`。当引用计数为零时，会`调用驱动程序的移除回调函数`。该设备会从驱动程序的设备列表中移除，并且`驱动程序的引用计数会减一`。两者之间的`所有符号链接都会被移除`。

当`移除一个驱动程序`时，会`遍历它所支持的设备列表`，并`为每个设备调用驱动程序的移除回调函数`。设备会从该列表中移除，同时符号链接也会被删除。



## Bus 类型

### Bus 结构体定义


```c
// include/linux/device.h
struct bus_type {
	const char		*name;              // bus 名
	const char		*dev_name;          // 用于子系统枚举设备的表达式，如 `sprint(buffer, "foo%u", dev->id)`
	struct device		*dev_root;      // 用作父(设备)的默认设备。
	const struct attribute_group **bus_groups;      // 总线的默认属性。
	const struct attribute_group **dev_groups;      // 总线上设备的默认属性。
	const struct attribute_group **drv_groups;      // 总线上设备驱动的默认属性。

	int (*match)(struct device *dev, struct device_driver *drv);		// 驱动和设备的匹配函数：每当为该总线添加新设备或驱动程序时，可能会多次调用此函数。如果给定的驱动程序可以处理给定的设备，则应返回一个正值，否则返回零。如果无法确定驱动程序是否支持该设备，它也可能返回错误代码。如果返回 -EPROBE_DEFER ，则会将该设备排队等待延迟探测。
	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);		// 当设备添加、移除或发生其他一些会生成 uevent 的情况时调用，以便添加环境变量。uevent 是 Linux 内核中用于实现内核空间与用户空间通信的一种机制，主要用于通知用户空间关于硬件设备的状态变化（如设备插入、移除、属性变更等）。它是 Linux 设备模型（Device Model）的重要组成部分，属于 热插拔事件（Hotplug Events） 的一种实现方式。
	int (*probe)(struct device *dev);			// 当有`新设备或驱动程序`添加到该总线时调用此函数，并回调特定驱动程序的探测函数以初始化匹配的设备。
	int (*remove)(struct device *dev);			// 当`设备`从该总线移除时调用。
	void (*shutdown)(struct device *dev);		// 在关机时调用，以使`设备进入静止状态`

	int (*online)(struct device *dev);			// 在设备离线后，调用此函数使设备重新上线。
	int (*offline)(struct device *dev);			// 调用此函数以使设备离线以便热移除。可能会失败。

	int (*suspend)(struct device *dev, pm_message_t state);		// 当此总线上的设备想要进入睡眠模式时调用。
	int (*resume)(struct device *dev);		// 调用此函数可使该总线上的设备退出睡眠模式。

	int (*num_vf)(struct device *dev);		// 调用此函数以查明该总线上的设备支持多少个`虚拟函数`。

	int (*dma_configure)(struct device *dev);		// 用于设置此总线上某个设备的直接内存访问（DMA）配置。

	const struct dev_pm_ops *pm;		// 此总线的电源管理操作，回调特定设备驱动程序的电源管理操作。

	const struct iommu_ops *iommu_ops;		// 该总线上特定于IOMMU的操作，用于将IOMMU驱动程序实现附加到总线上，并允许驱动程序执行总线特定的设置。

	struct subsys_private *p;			// 驱动程序核心的私有数据，只有驱动程序核心可以操作此数据。
	struct lock_class_key lock_key;		// 供锁验证器使用的锁类密钥

	bool need_parent_lock;				// 当探测或移除该总线上的设备时，设备核心是否应锁定该设备的父设备。
};

extern int __must_check bus_register(struct bus_type *bus);
```


### 声明一种 Bus

内核中的每种总线类型（PCI、USB 等）都应该声明一个这种类型的静态对象。它们必须初始化name字段，并且可以选择初始化匹配回调函数：

```c
// drivers/pci/pci-driver.c
struct bus_type pci_bus_type = {
	.name = "pci",
	.match = pci_bus_match,
	...
};
EXPORT_SYMBOL(pci_bus_type);
```

该结构体应通过头文件导出给驱动程序：

```c
extern struct bus_type pci_bus_type;
```


### 注册一种 Bus

当一个总线驱动程序初始化时，它会调用 `bus_register`。这会初始化总线对象中的其余字段，并将其插入到全局总线类型列表中。一旦总线对象注册完成，总线驱动程序就可以使用其中的字段。

```c
// include/linux/device.h
extern int __must_check bus_register(struct bus_type *bus);

// drivers/base/bus.c
int bus_register(struct bus_type *bus){}
```


### Bus 相关回调函数

#### match()

设备ID结构的格式以及比较它们的语义本质上是特定于总线的。

`驱动程序`通常会声明一个`数组`，该数组包含它们`所支持的`、位于`特定于总线`的`驱动程序结构`中的`设备的设备ID`。

匹配回调的目的是`让总线有机会通过将驱动程序支持的设备ID与特定设备的设备ID进行比较`，来`确定特定驱动程序是否支持特定设备`，同时又不牺牲总线特定的功能或类型安全性。

当一个`驱动程序`在`总线上注册时`，会遍历总线的设备列表，并对每个`没有关联驱动程序`的设备调用匹配回调函数。

```
int (*match)(struct device *dev, struct device_driver *drv);		// return > 0 if matched else <=0, <0 is error code
```


### Bus 设备与驱动程序列表

设备列表和驱动程序列表旨在取代许多总线维护的本地列表。

它们分别是结构体`设备列表`和结构体设备`驱动程序列表`。`总线驱动程序`可随意使用这些列表，但可能需要`转换为特定于总线的类型`。

LDM (Linux Device Model) 核心提供了用于遍历每个列表的辅助函数：

```c
// include/linux/device.h
// drivers/base/bus.c
int bus_for_each_dev(struct bus_type * bus, struct device * start,
                     void * data, int (*fn)(struct device *, void *));

int bus_for_each_drv(struct bus_type * bus, struct device_driver * start,
                     void * data, int (*fn)(struct device_driver *, void *));

/*
@bus：表示要遍历的总线类型。
@start: 表示迭代开始的设备/驱动。如果为NULL，则从列表的第一个设备/驱动开始。
@data：这是自定义的传递给回调函数的数据，可以是任何类型的信息，用于回调函数的处理。
@fn：这是对每个设备调用的回调函数。该函数应该接受一个设备/驱动指针和@data作为参数。

对每个设备调用@fn函数。如果@fn返回`非零值`，迭代将终止，并返回该值。这允许回调函数控制迭代过程，例如，如果找到特定设备，可以提前终止迭代。
*/
```

这些辅助函数会遍历相应的列表，并为列表中的每个设备或驱动程序调用回调函数。

所有的列表访问操作都会通过获取总线锁（当前为读锁）来进行同步。

在调用回调函数之前，列表中每个对象的引用计数会增加；在获取下一个对象之后，引用计数会减少。`调用回调函数时不会持有锁`。这意味着如果调用者需要保留设备信息，必须在回调函数中增加设备的引用计数，以防止设备在迭代结束前被释放。



### Bus 与 sysfs

有一个名为“bus”的顶级目录。

每个总线在总线目录中都有一个目录，以及两个默认目录：

```
/sys/bus/pci/
|-- devices
`-- drivers
```

向总线注册的驱动程序会在总线的驱动程序目录中获得一个目录：

```
/sys/bus/pci/
|-- devices
`-- drivers
    |-- Intel ICH
    |-- Intel ICH Joystick
    |-- agpgart
    `-- e100
```

在该类型总线上发现的每个设备，都会在总线的设备目录中创建一个符号链接，指向`物理层级结构`中该设备的目录：

```
/sys/bus/pci/
|-- devices
|   |-- 00:00.0 -> ../../../devices/pci0/00:00.0
|   |-- 00:01.0 -> ../../../devices/pci0/00:01.0
|   `-- 00:02.0 -> ../../../devices/pci0/00:02.0
`-- drivers
```


### Bus Attribute 属性导出

Bus 导出属性到用户空间 的 结构定义：

```c
// include/linux/device.h
struct bus_attribute {
	struct attribute	attr;
	ssize_t (*show)(struct bus_type *bus, char *buf);
	ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
};

// include/linux/sysfs.h
struct attribute {
	const char		*name;		// sysfs中的文件名
	umode_t			mode;		// sysfs中的文件的权限
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	bool			ignore_lockdep:1;
	struct lock_class_key	*key;
	struct lock_class_key	skey;
#endif
};
```

总线驱动程序可以使用`BUS_ATTR_RW`宏导出属性，该宏的工作方式与设备的`DEVICE_ATTR_RW`宏类似。例如，像这样的定义：

```c
static BUS_ATTR_RW(debug);
```

等同于声明：

```c
static bus_attribute bus_attr_debug;
```

然后，可以使用以下命令，在`总线`的`sysfs`目录中添加和删除该属性：

```c
// include/linux/device.h
// drivers/base/bus.c
int bus_create_file(struct bus_type *, struct bus_attribute *);
void bus_remove_file(struct bus_type *, struct bus_attribute *);
```



## Device Driver 设计模式





